[{"content":"128阈值 在灰度图像中，像素值范围是0到255（共 256 个离散级）。把灰度图二值化时常见的简单规则是：\n若像素值 $I(x,y)\\geq T$，则置为 255（白） 否则置为0（黑） 当T=128时，即将灰度中点作为阈值：所有亮度 $\\ge 128$ 的像素判为“亮”，小于的则判为”暗。\n关于图片适用性的判别，则可以用似然比检验法进行确认（只不过需要知道前景和后景的分布）：\n假设图像像素由前景和背景组成，每个部分的像素值服从高斯分布（正态分布）。设图像有 N 个像素，像素值为 $x_{i} (i=1,2,\u0026hellip;,N)$ 。我们需要比较两个假设：\n零假设（$H_{0}$）：阈值 T=128是合理的，即图像二值化使用固定阈值128。 备择假设（$H_{1}$）：阈值 T 是任意的，即存在一个最优阈值 $T^*$ 能更好地拟合图像数据。 似然比检验通过比较在 $H_{0}$ 和 $H_{1}$ 下的最大似然值来评估 $H_{0}$ 是否被拒绝。\n假设前景和背景的像素值分别服从高斯分布：\n背景像素 ($x_{i} \\leq T $) 服从 $ N(\\mu_{b},\\sigma_{b}^{2})$\n前景像素 ($ x_{i}\u0026gt;T $) 服从 $ N(\\mu_{f},\\sigma_{f}^{2}) $\n则似然函数(给定阈值T)为:\n$$ L(\\mu_{b},\\sigma_{b}^{2},\\mu_{f},\\sigma_{f}^{2},T)=\\prod_{x_{i}\\leq T}\\frac{1}{\\sqrt{2\\pi\\sigma_{b}^{2}}}\\exp\\left(-\\frac{(x_{i}-\\mu_{b})^{2}}{2\\sigma_{b}^{2}}\\right)\\times\\prod_{x_{i}\u003eT}\\frac{1}{\\sqrt{2\\pi\\sigma_{f}^{2}}}\\exp\\left(-\\frac{(x_{i}-\\mu_{f})^{2}}{2\\sigma_{f}^{2}}\\right) $$ 分别计算 $L_{0} 和 L_{1} $，似然比定义为： $$ \\Lambda=\\frac{L_{0}}{L_{1}} $$ 检验统计量为 $ \\lambda=-2\\ln\\Lambda $，在$ H_{0} $下，$ \\lambda $ 近似服从自由度为1的卡方分布（因为$ H_{1} $比$ H_{0} $多一个自由参数T）。\n选择显著性水平$ \\alpha $（通常为0.05），对应的卡方临界值为 $ \\chi^{2}_{1,1-\\alpha} $（例如，$ \\alpha=0.05 $时，临界值为3.841）。 如果$ \\lambda\u0026gt;\\chi^{2}{1,1-\\alpha} $，则拒绝$ H{0} $，表示阈值128不合理；否则不拒绝$ H_{0} $，表示128阈值可接受。 均值阈值 核心思想：使用图像所有像素灰度值的平均值作为阈值。\n设图像有N个像素，第 $i$ 个像素的灰度值为 $p_i$ ，则平均阈值 $T$ 计算为： $$ T = \\frac{1}{N} \\sum_{i=1}^{N} p_i $$代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import cv2 import numpy as np import matplotlib.pyplot as plt def mean_thresholding(image): \u0026#34;\u0026#34;\u0026#34; 平均阈值二值化 \u0026#34;\u0026#34;\u0026#34; # 计算平均阈值 mean_value = np.mean(image) # 应用阈值 _, binary_image = cv2.threshold(image, mean_value, 255, cv2.THRESH_BINARY) return binary_image, mean_value # 读取图像 image = cv2.imread(\u0026#39;document.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE) # 应用平均阈值 binary_result, threshold_value = mean_thresholding(image) print(f\u0026#34;计算得到的平均阈值: {threshold_value}\u0026#34;) # 显示结果 plt.figure(figsize=(12, 4)) plt.subplot(1, 3, 1) plt.imshow(image, cmap=\u0026#39;gray\u0026#39;) plt.title(\u0026#39;原图\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.subplot(1, 3, 2) plt.hist(image.ravel(), 256, [0, 256]) plt.axvline(threshold_value, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, label=f\u0026#39;阈值 = {threshold_value:.2f}\u0026#39;) plt.title(\u0026#39;灰度直方图\u0026#39;) plt.legend() plt.subplot(1, 3, 3) plt.imshow(binary_result, cmap=\u0026#39;gray\u0026#39;) plt.title(\u0026#39;平均阈值二值化结果\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.tight_layout() plt.show() OSTU大津法 核心准则：最优阈值 ($ T^*$) 是使两类像素的 “类间方差” 最大的阈值。\n背后逻辑：类间方差越大，说明前景与背景的灰度差异越显著，分割效果越好；反之，类间方差越小，两类灰度重叠越严重，分割效果越差。\n关键前提：总方差 = 类内方差 + 类间方差（总方差不随阈值 t 变化），因此 “最大化类间方差” 等价于 “最小化类内方差”，二者是完全等价的优化目标。\n假设输入图像为单通道灰度图，灰度级范围为 $[0, L-1]$ （通常 $L=256$ ，即8位图像），定义：\n$n_i$ ：灰度值为 $i$ 的像素个数； 总像素数 $N = \\sum_{i=0}^{L-1} n_i$ ； 灰度级 $i$ 的概率 $p_i = \\frac{n_i}{N}$ ，满足 $\\sum_{i=0}^{L-1} p_i = 1$ （所有灰度的概率和为1）。 对于任意候选阈值 $t$ （ $0 \\leq t \\leq L-2$ ），将像素分为 $C_0$ （0t）和 $C_1$ （t+1L-1），定义以下关键统计量：\n（1）两类的概率（权重） 背景类 $C_0$ 的概率： $\\omega_0(t) = \\sum_{i=0}^t p_i$ （所有灰度≤t的像素占比）；\n前景类 $C_1$ 的概率： $\\omega_1(t) = \\sum_{i=t+1}^{L-1} p_i = 1 - \\omega_0(t)$ （所有灰度\u0026gt;t的像素占比）。\n（2）两类的均值（灰度中心） 背景类 $C_0$ 的均值： $\\mu_0(t) = \\frac{1}{\\omega_0(t)} \\sum_{i=0}^t i \\cdot p_i$ （仅当 $\\omega_0(t) \\neq 0$ ，否则均值无意义）；\n前景类 $C_1$ 的均值： $\\mu_1(t) = \\frac{1}{\\omega_1(t)} \\sum_{i=t+1}^{L-1} i \\cdot p_i$ （仅当 $\\omega_1(t) \\neq 0$ ）；\n全局均值（整幅图像的灰度均值）： $\\mu = \\sum_{i=0}^{L-1} i \\cdot p_i = \\omega_0(t) \\cdot \\mu_0(t) + \\omega_1(t) \\cdot \\mu_1(t)$ （加权平均，权重为两类概率）。\n类间方差的定义是：两类均值与全局均值的加权平方和，权重为两类概率： $$ \\sigma_b^2(t) = \\omega_0(t) \\cdot (\\mu_0(t) - \\mu)^2 + \\omega_1(t) \\cdot (\\mu_1(t) - \\mu)^2 $$ 简化有： $$ \\boxed{\\sigma_b^2(t) = \\omega_0(t) \\cdot \\omega_1(t) \\cdot (\\mu_0(t) - \\mu_1(t))^2} $$大津算法的具体实现步骤如下（以8位图像 $L=256$ 为例）： 步骤1：计算灰度概率分布 遍历图像所有像素，统计每个灰度级 $i$ （0~255）的像素数 $n_i$ ，并计算概率 $p_i = \\frac{n_i}{N}$ （ $N$ 为总像素数）。\n步骤2：遍历所有候选阈值 遍历 $t \\in [0, 254]$ （阈值需将灰度级分为非空两类，故 $t$ 不取255），对每个 $t$ 执行以下计算：\n步骤3：计算两类的概率与均值 背景概率 $\\omega_0(t) = \\sum_{i=0}^t p_i$ ；\n前景概率 $\\omega_1(t) = 1 - \\omega_0(t)$ ；\n背景均值 $\\mu_0(t) = \\frac{1}{\\omega_0(t)} \\sum_{i=0}^t i \\cdot p_i$ （若 $\\omega_0(t) = 0$ ，跳过该 $t$ ）；\n前景均值 $\\mu_1(t) = \\frac{1}{\\omega_1(t)} \\sum_{i=t+1}^{255} i \\cdot p_i$ （若 $\\omega_1(t) = 0$ ，跳过该 $t$ ）。\n步骤4：计算类间方差 用简化公式计算 $\\sigma_b^2(t) = \\omega_0(t) \\cdot \\omega_1(t) \\cdot (\\mu_0(t) - \\mu_1(t))^2$ 。\n步骤5：寻找最优阈值 记录所有 $t$ 对应的 $\\sigma_b^2(t)$ ，找到使 $\\sigma_b^2(t)$ 最大的阈值 $t^*$ （若有多个 $t$ 对应最大方差，取任意一个即可）。\n步骤6：二值化分割 将图像中灰度值 $\\leq t^$ 的像素设为背景（通常为0），灰度值 $\u0026gt; t^$ 的像素设为前景（通常为255），或根据需求反转（前景为0，背景为255）。\n示例验证（简化场景） 为直观理解，假设一幅图像的灰度级仅为 $[0,1,2,3]$ ，统计信息如下：\n灰度级 $i$ 0 1 2 3 像素数 $n_i$ 10 20 30 40 概率 $p_i$ 0.1 0.2 0.3 0.4 总像素数 $N=100$ ，全局均值 $\\mu = 0 \\times 0.1 + 1 \\times 0.2 + 2 \\times 0.3 + 3 \\times 0.4 = 2.0$ 。\n遍历候选阈值 $t=0,1,2$ ：\n当 $t=0$ 时： $\\omega_0 = 0.1$ ， $\\mu_0 = 0$ ；\n$\\omega_1 = 0.9$ ， $\\mu_1 = \\frac{1 \\times 0.2 + 2 \\times 0.3 + 3 \\times 0.4}{0.9} = \\frac{2.0}{0.9} \\approx 2.222$ ；\n$\\sigma_b^2 = 0.1 \\times 0.9 \\times (0 - 2.222)^2 \\approx 0.444$ 。\n当 $t=1$ 时： $\\omega_0 = 0.1 + 0.2 = 0.3$ ， $\\mu_0 = \\frac{0 \\times 0.1 + 1 \\times 0.2}{0.3} \\approx 0.667$ ；\n$\\omega_1 = 0.3 + 0.4 = 0.7$ ， $\\mu_1 = \\frac{2 \\times 0.3 + 3 \\times 0.4}{0.7} = \\frac{1.8}{0.7} \\approx 2.571$ ；\n$\\sigma_b^2 = 0.3 \\times 0.7 \\times (0.667 - 2.571)^2 \\approx 0.760$ 。\n当 $t=2$ 时： $\\omega_0 = 0.1 + 0.2 + 0.3 = 0.6$ ， $\\mu_0 = \\frac{0 \\times 0.1 + 1 \\times 0.2 + 2 \\times 0.3}{0.6} \\approx 1.333$ ；\n$\\omega_1 = 0.4$ ， $\\mu_1 = 3$ ；\n$\\sigma_b^2 = 0.6 \\times 0.4 \\times (1.333 - 3)^2 \\approx 0.667$ 。\n最优阈值：\n类间方差最大值为 $\\approx 0.760$ ，对应 $t^*=1$ 。因此，最优分割为：灰度01（背景）、灰度23（前景），分割效果最优。\n示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 import cv2 import numpy as np import matplotlib.pyplot as plt def otsu_threshold_manual(gray_img): \u0026#34;\u0026#34;\u0026#34; 手动实现大津算法，返回最优阈值和二值化图像 :param gray_img: 输入灰度图（shape: (H, W)，值范围0-255） :return: (optimal_thresh, binary_img) \u0026#34;\u0026#34;\u0026#34; # 步骤1：计算灰度概率分布（灰度直方图） H, W = gray_img.shape total_pixels = H * W # 总像素数 N hist, _ = np.histogram(gray_img.flatten(), bins=256, range=[0, 256]) # 统计每个灰度级的像素数 n_i p = hist / total_pixels # 灰度级概率 p_i = n_i / N # 步骤2：遍历所有候选阈值 t（0~254，避免某一类为空） max_var = 0.0 # 最大类间方差 optimal_thresh = 0 # 最优阈值 for t in range(0, 255): # 步骤3：计算两类的概率 ω0、ω1 omega0 = np.sum(p[:t+1]) # C0：0~t 的概率和 omega1 = 1 - omega0 # C1：t+1~255 的概率和（ω0+ω1=1） # 跳过空类（避免除以零） if omega0 == 0 or omega1 == 0: continue # 步骤4：计算两类的均值 μ0、μ1 # μ0 = sum(i*p_i for i=0~t) / omega0 mu0 = np.sum(np.arange(t+1) * p[:t+1]) / omega0 # μ1 = sum(i*p_i for i=t+1~255) / omega1 mu1 = np.sum(np.arange(t+1, 256) * p[t+1:]) / omega1 # 步骤5：计算类间方差（使用简化公式） between_var = omega0 * omega1 * (mu0 - mu1) ** 2 # 更新最大方差和最优阈值 if between_var \u0026gt; max_var: max_var = between_var optimal_thresh = t # 步骤6：根据最优阈值二值化 binary_img = np.where(gray_img \u0026lt;= optimal_thresh, 0, 255).astype(np.uint8) # 0=背景，255=前景 # 若需反转前景背景，改为：np.where(gray_img \u0026lt;= optimal_thresh, 255, 0) return optimal_thresh, binary_img # ---------------------- 主流程 ---------------------- # 1. 读取图像并转为灰度图 img_path = \u0026#34;test_image.jpg\u0026#34; # 替换为你的图像路径 img = cv2.imread(img_path) if img is None: print(\u0026#34;Error: 无法读取图像，请检查路径是否正确！\u0026#34;) exit() gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 2. 手动调用大津算法 manual_thresh, manual_binary = otsu_threshold_manual(gray_img) # 3. 对比 OpenCV 结果（验证正确性） cv2_thresh, cv2_binary = cv2.threshold(gray_img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) # 4. 显示结果 plt.figure(figsize=(15, 5)) # 原图 plt.subplot(1, 4, 1) plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)) plt.title(\u0026#34;原图\u0026#34;) plt.axis(\u0026#34;off\u0026#34;) # 灰度图 plt.subplot(1, 4, 2) plt.imshow(gray_img, cmap=\u0026#34;gray\u0026#34;) plt.title(\u0026#34;灰度图\u0026#34;) plt.axis(\u0026#34;off\u0026#34;) # 手动实现二值化 plt.subplot(1, 4, 3) plt.imshow(manual_binary, cmap=\u0026#34;gray\u0026#34;) plt.title(f\u0026#34;手动实现大津二值化\\n阈值={manual_thresh}\u0026#34;) plt.axis(\u0026#34;off\u0026#34;) # OpenCV 实现二值化（对比） plt.subplot(1, 4, 4) plt.imshow(cv2_binary, cmap=\u0026#34;gray\u0026#34;) plt.title(f\u0026#34;OpenCV 大津二值化\\n阈值={cv2_thresh:.0f}\u0026#34;) plt.axis(\u0026#34;off\u0026#34;) plt.tight_layout() plt.show() # 输出阈值对比（验证手动实现正确性） print(f\u0026#34;手动实现最优阈值：{manual_thresh}\u0026#34;) print(f\u0026#34;OpenCV 最优阈值：{cv2_thresh:.0f}\u0026#34;) print(f\u0026#34;两者阈值是否一致：{manual_thresh == int(cv2_thresh)}\u0026#34;) # 保存结果（可选） cv2.imwrite(\u0026#34;manual_otsu_binary.jpg\u0026#34;, manual_binary) print(\u0026#34;手动实现二值化结果已保存！\u0026#34;) ","date":"2025-12-02T20:52:12+08:00","image":"https://Entars.github.io/p/%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E4%BA%8C%E5%80%BC%E5%8C%96/wallpaper_hu_d180d73a98ffb91a.png","permalink":"https://Entars.github.io/p/%E5%85%A8%E5%B1%80%E9%98%88%E5%80%BC%E4%BA%8C%E5%80%BC%E5%8C%96/","title":"全局阈值二值化"},{"content":"核心 逻辑回归的目的和结果是“分类”，其中间过程是”回归“，通过回归模型计算出可能性，再加上阈值，可能性超过阈值是一类，低于阈值为一类\nSigmond函数 Sigmond函数为逻辑回归算法的拟合函数： $$ f(z) = \\frac{1}{1 + e^{-z}} $$\n推广至多元 多元线性回归方程的一般形式为： $$ y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\cdots + \\beta_p x_p $$ 矩阵形式为$\\boldsymbol{Y}=\\boldsymbol{X}\\boldsymbol{\\beta}$，其中： $$ \\boldsymbol{Y} = \\begin{bmatrix} y_{1} \\\\ y_{2} \\\\ \\vdots \\\\ y_{n} \\end{bmatrix}, \\quad \\boldsymbol{X} = \\begin{bmatrix} 1 \u0026 x_{11} \u0026 \\cdots \u0026 x_{1p} \\\\ 1 \u0026 x_{21} \u0026 \\cdots \u0026 x_{2p} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 x_{n1} \u0026 \\cdots \u0026 x_{np} \\end{bmatrix}, \\quad \\boldsymbol{\\beta} = \\begin{bmatrix} \\beta_{0} \\\\ \\beta_{1} \\\\ \\vdots \\\\ \\beta_{p} \\end{bmatrix} $$ 令其为预测为正例的概率P(Y=1)，带入Sigmond函数有： $$ P(Y=1) = \\frac{1}{1 + e^{-X\\beta}} $$最大似然估计 该方法用于求解方程中的${\\beta}$值，该方法的基础为似然函数（理论基础为概率论中的后验概率），即一个事件实际已经发生了，反推在什么参数条件下，这个事件发生的概率最大。\n在二分类问题中，$y$ 只取 0 或 1，可以组合起来表示 $y$ 的概率： $$ P(y) = P(y=1)^{y} P(y=0)^{1-y} $$ 我们可以把 $y=1$ 代入上式验证下：\n左边是 $P(y=1)$； 右边是 $P(y=1)^{1} P(y=0)^{0}$，也为 $P(y=1)$。 上面的式子，更严谨的写法需要加上特征 $x$ 和参数 $\\beta$： $$ P(y|x, \\beta) = P(y=1|x, \\beta)^{y}[1 - P(y=1|x, \\beta)]^{1-y} $$ 前面说了，$\\frac{1}{1+e^{-x\\beta}}$ 表示的就是 $P(y=1)$，代入上式：\n$$ P(y|x, \\beta) = \\left(\\frac{1}{1+e^{-x\\beta}}\\right)^{y}\\left(1 - \\frac{1}{1+e^{-x\\beta}}\\right)^{1-y} $$ 根据最优 $\\beta$ 的定义，也就是最大化我们见到的样本数据的概率，即求下式的最大值：\n$$ \\mathcal{L}(\\beta) = \\prod_{i=1}^{n} P(y_{i} \\mid x_{i}, \\beta) = \\prod_{i=1}^{n}\\left(\\frac{1}{1+e^{-x_{i} \\beta}}\\right)^{y_{i}}\\left(1 - \\frac{1}{1+e^{-x_{i} \\beta}}\\right)^{1-y_{i}} $$ 这个式子来源于$\\mathcal{L}(\\beta|x) = P(x|\\beta)$，即对于某个观测值 $y_i$，似然函数的值 $\\mathcal{L}(\\beta|y_{i})$，就等于条件概率的值 $P(y_{i}|\\beta)$。\n另外我们知道，如果事件 A 与事件 B 相互独立，那么两者同时发生的概率为 $P(A)^{*}P(B)$。那么我们观测到的 $y_1, y_2, \\ldots, y_n$，他们同时发生的概率就是 $\\prod_{i=1}^{n} P(y_{i}|\\beta)$。\n因为一系列的 $x_i$ 和 $y_i$ 都是我们实际观测到的数据，式子中未知的只有 $\\beta$。因此，现在问题就成了求 $\\beta$ 在取什么值的时候，$\\mathcal{L}(\\beta)$ 能达到最大值。\n$\\mathcal{L}(\\beta)$ 是所有观测到的 $y$ 发生概率的乘积，这种情况求最大值比较麻烦，一般我们会先取对数，将乘积转化成加法。\n取对数后，转化成下式：\n$$ \\log\\mathcal{L}(\\beta) = \\sum_{i=1}^{n}\\left(\\left[y_{i} \\cdot \\log\\left(\\frac{1}{1+e^{-x_{i}\\beta}}\\right)\\right] + \\left[\\left(1-y_{i}\\right) \\cdot \\log\\left(1 - \\frac{1}{1+e^{-x_{i}\\beta}}\\right)\\right]\\right) $$ 接下来想办法求上式的最大值就可以了，求解前，我们要提一下逻辑回归的损失函数。\n损失函数 可以采用残差平方和，带入Sigmond函数有： $$ Q = \\sum_{i=1}^{n} \\left( y_i - \\frac{1}{1 + e^{-\\mathbf{x}_i \\boldsymbol{\\beta}}} \\right)^2 $$ 因为非凸，容易陷入局部极小，所以对两边取对数，即对数损失函数: $$ J(\\beta) = -\\log\\mathcal{L}(\\beta) = -\\sum_{i=1}^{n}\\left[y_{i}\\log P\\left(y_{i}\\right)+\\left(1-y_{i}\\right)\\log\\left(1-P\\left(y_{i}\\right)\\right)\\right] $$ 对于该问题的求解，可以用梯度下降法\n","date":"2025-11-29T14:52:43+08:00","image":"https://Entars.github.io/p/logistic%E5%9B%9E%E5%BD%92/wallpaper_hu_e8dc5bda846f916.jpeg","permalink":"https://Entars.github.io/p/logistic%E5%9B%9E%E5%BD%92/","title":"Logistic回归"},{"content":"一元线性回归 基本方程： $$ y = \\beta_{0} + \\beta_{1}x $$ 当给定参数$\\beta_{0}$和$\\beta_{1}$后，函数图像呈现一条直线。当我们只用一个$x$来预测$y$，就是一元线性回归，但在一般条件下，这两个参数是未知的，我们知道的只有$x$和$y$，在二维图像上表现为一个个单独的点，线性回归就是要找到一条直线，尽可能让这条线去拟合图中的点（即所有的$x$和$y$的组合）。\n这是非常理想的情况下，在实际中，数据点会十分散乱，线性回归就是在杂乱中寻找规律：\n损失函数 既然是用直线拟合散点，为什么最终得到的直线是蓝色的那根而不是绿色的，散点都在这两条线附近，所以我们需要一个评判标准，用于评价哪条才是最“合适”的。\n一个很直观的标准就是看哪条线和散点之间的偏差最大，也就是真实值和预测值间的差值，即残差，用公式表示即： $$ e = y - \\hat{y} $$ 图像表示为：\n对于我们数据中的每个点如此计算一遍，再将所有的$e_{i}^{2}$相加，就能量化出拟合的直线和实际之间的误差。公式表示为： $$ Q=\\sum_{i=1}^{n}(y_{i}-\\hat{y}_{i})^{2}=\\sum_{i=1}^{n}(y_{i}-(\\hat{\\beta}_{0}+\\hat{\\beta}_{1}x_{i}))^{2} $$ 这个公式是残差平方和，即SSE（Sum of Squares for Error），在机器学习中它是回归问题中最常用的损失函数。\n现在我们知道了损失函数是衡量回归模型误差的函数，也就是我们要的“直线”的评价标准。这个函数的值越小，说明直线越能拟合我们的数据。\n最小二乘估计 最小二乘估计是用来计算$\\beta_{0}$和$\\beta_{1}$的方法，我们知道，两点确定一线，有两组x，y的值，就能算出来$\\beta_{0}$和$\\beta_{1}$。但是现在我们有很多点，且并不正好落在一条直线上，这么多点每两点都能确定一条直线，这到底要怎么确定选哪条直线呢？\n将一切回归到评价准则，对于一条最适合的线，其损失函数的值一定是最小的，对于一个一元二次函数，其导函数为0的点处取到最小函数值，而在损失函数中，存在两个变量，为二元二次函数，其函数图像大致为：\n在微积分中，若闭区间内是凹函数，则极小值即为最小值，导数为0时，Q取最小值，因此对两个未知量求偏导，令其为0，则： $$ \\frac{\\partial Q}{\\partial\\beta_{0}}=2\\sum_{i=1}^{n}\\left(y_{i}-\\hat{\\beta}_{0}-\\hat{\\beta}_{1}x_{i}\\right)=0 $$$$ \\frac{\\partial Q}{\\partial\\beta_{1}}=2\\sum_{i=1}^{n}\\left(y_{i}-\\hat{\\beta}_{0}-\\hat{\\beta}_{1}x_{i}\\right)x_{i}=0 $$将散点值代入，即可求得。\n","date":"2025-11-24T20:52:57+08:00","image":"https://Entars.github.io/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/paperwall_hu_2a6997d9034a1348.png","permalink":"https://Entars.github.io/p/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","title":"线性回归"},{"content":"创建数组 从列表创建 1 2 3 4 5 6 7 8 9 10 11 12 13 # 一维数组 arr1d = np.array([1, 2, 3, 4, 5]) print(arr1d) # [1 2 3 4 5] # 二维数组 arr2d = np.array([[1, 2, 3], [4, 5, 6]]) print(arr2d) # [[1 2 3] # [4 5 6]] # 三维数组 arr3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) print(arr3d) 特殊数组创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 全零数组 zeros = np.zeros((3, 4)) print(zeros) # 全一数组 ones = np.ones((2, 3)) print(ones) # 单位矩阵 identity = np.eye(3) print(identity) # 等差数列 lin_arr = np.linspace(0, 10, 5) # 从0到10，5个等间距数 print(lin_arr) # [ 0. 2.5 5. 7.5 10. ] # 等差数列（指定步长） arange_arr = np.arange(0, 10, 2) # 从0到10，步长为2 print(arange_arr) # [0 2 4 6 8] # 随机数组 random_arr = np.random.random((2, 3)) # 0-1之间的随机数 print(random_arr) 数组属性 1 2 3 4 5 6 7 8 arr = np.array([[1, 2, 3], [4, 5, 6]]) print(\u0026#34;数组:\u0026#34;, arr) print(\u0026#34;维度:\u0026#34;, arr.ndim) # 2 print(\u0026#34;形状:\u0026#34;, arr.shape) # (2, 3) print(\u0026#34;元素总数:\u0026#34;, arr.size) # 6 print(\u0026#34;数据类型:\u0026#34;, arr.dtype) # int64 print(\u0026#34;元素大小(字节):\u0026#34;, arr.itemsize) # 8 数组索引与切片 一维数组 1 2 3 4 5 6 7 8 arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) print(arr[2]) # 2 print(arr[2:5]) # [2 3 4] print(arr[:5]) # [0 1 2 3 4] print(arr[5:]) # [5 6 7 8 9] print(arr[::2]) # [0 2 4 6 8] 步长为2 print(arr[::-1]) # [9 8 7 6 5 4 3 2 1 0] 反转 多维数组 1 2 3 4 5 6 arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(arr[0, 1]) # 2 print(arr[1, :]) # [4 5 6] 第二行 print(arr[:, 1]) # [2 5 8] 第二列 print(arr[0:2, 1:3]) # [[2 3] [5 6]] 子数组 布尔索引 1 2 3 4 5 6 7 8 9 arr = np.array([1, 2, 3, 4, 5, 6]) # 选择大于3的元素 mask = arr \u0026gt; 3 print(mask) # [False False False True True True] print(arr[mask]) # [4 5 6] # 直接使用条件 print(arr[arr % 2 == 0]) # [2 4 6] 偶数 数组操作 形状操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 arr = np.arange(12) print(\u0026#34;原始数组:\u0026#34;, arr) # 重塑形状 reshaped = arr.reshape(3, 4) print(\u0026#34;重塑后:\\n\u0026#34;, reshaped) # 展平 flattened = reshaped.flatten() print(\u0026#34;展平:\u0026#34;, flattened) # 转置 transposed = reshaped.T print(\u0026#34;转置:\\n\u0026#34;, transposed) 数组拼接 1 2 3 4 5 6 7 8 9 10 a = np.array([[1, 2], [3, 4]]) b = np.array([[5, 6], [7, 8]]) # 垂直拼接 v_stack = np.vstack((a, b)) print(\u0026#34;垂直拼接:\\n\u0026#34;, v_stack) # 水平拼接 h_stack = np.hstack((a, b)) print(\u0026#34;水平拼接:\\n\u0026#34;, h_stack) 数组分割 1 2 3 4 5 6 7 8 9 10 11 12 13 14 arr = np.arange(12).reshape(3, 4) print(\u0026#34;原始数组:\\n\u0026#34;, arr) # 水平分割 h_split = np.hsplit(arr, 2) print(\u0026#34;水平分割:\u0026#34;) for part in h_split: print(part) # 垂直分割 v_split = np.vsplit(arr, 3) print(\u0026#34;垂直分割:\u0026#34;) for part in v_split: print(part) 数学运算 基本运算 1 2 3 4 5 6 7 8 a = np.array([1, 2, 3, 4]) b = np.array([5, 6, 7, 8]) print(\u0026#34;a + b =\u0026#34;, a + b) # [ 6 8 10 12] print(\u0026#34;a - b =\u0026#34;, a - b) # [-4 -4 -4 -4] print(\u0026#34;a * b =\u0026#34;, a * b) # [ 5 12 21 32] print(\u0026#34;a / b =\u0026#34;, a / b) # [0.2 0.333 0.429 0.5] print(\u0026#34;a ** 2 =\u0026#34;, a ** 2) # [ 1 4 9 16] 通用函数 1 2 3 4 5 6 7 arr = np.array([0, np.pi/2, np.pi]) print(\u0026#34;sin:\u0026#34;, np.sin(arr)) # [0. 1. 0.] print(\u0026#34;cos:\u0026#34;, np.cos(arr)) # [1. 0. -1.] print(\u0026#34;exp:\u0026#34;, np.exp(arr)) # 指数函数 print(\u0026#34;log:\u0026#34;, np.log(arr + 1)) # 自然对数 print(\u0026#34;sqrt:\u0026#34;, np.sqrt(arr)) # 平方根 统计函数 1 2 3 4 5 6 7 8 9 10 11 arr = np.array([[1, 2, 3], [4, 5, 6]]) print(\u0026#34;数组:\\n\u0026#34;, arr) print(\u0026#34;总和:\u0026#34;, np.sum(arr)) # 21 print(\u0026#34;平均值:\u0026#34;, np.mean(arr)) # 3.5 print(\u0026#34;标准差:\u0026#34;, np.std(arr)) # 1.7078 print(\u0026#34;方差:\u0026#34;, np.var(arr)) # 2.9167 print(\u0026#34;最小值:\u0026#34;, np.min(arr)) # 1 print(\u0026#34;最大值:\u0026#34;, np.max(arr)) # 6 print(\u0026#34;沿轴0求和:\u0026#34;, np.sum(arr, axis=0)) # [5 7 9] print(\u0026#34;沿轴1求和:\u0026#34;, np.sum(arr, axis=1)) # [6 15] 线性代数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 矩阵乘法 a = np.array([[1, 2], [3, 4]]) b = np.array([[5, 6], [7, 8]]) dot_product = np.dot(a, b) print(\u0026#34;矩阵乘法:\\n\u0026#34;, dot_product) # 行列式 det = np.linalg.det(a) print(\u0026#34;行列式:\u0026#34;, det) # 逆矩阵 inv = np.linalg.inv(a) print(\u0026#34;逆矩阵:\\n\u0026#34;, inv) # 特征值和特征向量 eigenvalues, eigenvectors = np.linalg.eig(a) print(\u0026#34;特征值:\u0026#34;, eigenvalues) print(\u0026#34;特征向量:\\n\u0026#34;, eigenvectors) 随机数生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 设置随机种子（保证结果可重现） np.random.seed(42) # 均匀分布 uniform = np.random.rand(3, 3) # 0-1均匀分布 print(\u0026#34;均匀分布:\\n\u0026#34;, uniform) # 正态分布 normal = np.random.randn(3, 3) # 标准正态分布 print(\u0026#34;正态分布:\\n\u0026#34;, normal) # 整数随机数 integers = np.random.randint(0, 10, (2, 3)) # 0-10的整数 print(\u0026#34;整数随机数:\\n\u0026#34;, integers) # 随机排列 arr = np.arange(10) np.random.shuffle(arr) print(\u0026#34;随机排列:\u0026#34;, arr) 数组保存与读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 创建示例数组 arr = np.arange(12).reshape(3, 4) # 保存为文本文件 np.savetxt(\u0026#39;array.txt\u0026#39;, arr) # 从文本文件读取 loaded = np.loadtxt(\u0026#39;array.txt\u0026#39;) print(\u0026#34;从文件读取:\\n\u0026#34;, loaded) # 保存为二进制文件 np.save(\u0026#39;array.npy\u0026#39;, arr) # 从二进制文件读取 loaded_binary = np.load(\u0026#39;array.npy\u0026#39;) print(\u0026#34;从二进制文件读取:\\n\u0026#34;, loaded_binary) # 保存为压缩的二进制文件 np.savez(\u0026#39;array_compressed.npz\u0026#39;, my_array=arr) # 从压缩文件读取 loaded_compressed = np.load(\u0026#39;array_compressed.npz\u0026#39;) print(\u0026#34;从压缩文件读取:\\n\u0026#34;, loaded_compressed[\u0026#39;my_array\u0026#39;]) 实用技巧 广播机制 1 2 3 4 5 6 7 8 9 10 # 数组与标量的运算（广播） arr = np.array([[1, 2, 3], [4, 5, 6]]) result = arr + 10 # 每个元素加10 print(\u0026#34;广播加法:\\n\u0026#34;, result) # 不同形状数组的运算 a = np.array([[1], [2], [3]]) # 形状 (3, 1) b = np.array([4, 5, 6]) # 形状 (3,) result = a + b # 广播为 (3, 3) print(\u0026#34;形状广播:\\n\u0026#34;, result) 条件运算 1 2 3 4 5 6 7 8 9 arr = np.array([1, 2, 3, 4, 5]) # where函数 result = np.where(arr \u0026gt; 3, arr, 0) # 大于3的保留，其他设为0 print(\u0026#34;条件运算:\u0026#34;, result) # [0 0 0 4 5] # 布尔运算 mask = (arr \u0026gt; 2) \u0026amp; (arr \u0026lt; 5) # 2 \u0026lt; arr \u0026lt; 5 print(\u0026#34;布尔掩码:\u0026#34;, mask) # [False False True True False] ","date":"2025-11-05T12:47:28+08:00","image":"https://Entars.github.io/p/numpy%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/1_hu_932a10a079e4a78d.jpg","permalink":"https://Entars.github.io/p/numpy%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","title":"Numpy使用手册"},{"content":"WordCard 技术文档 版本：1.0\n简介 WordClock 是基于 customtkinter 的桌面小工具，用于在桌面悬浮窗中循环显示单词及其翻译，并支持从 JSON 导入词表、将词表写入 SQLite 数据库、通过系统托盘控制程序、保存窗口位置及设置等功能。\n主要特点：\n悬浮、圆角、透明窗口，常驻桌面并支持拖动和隐藏到托盘。 自动按间隔随机切换单词并更新 UI。 支持将 JSON 词表导入到 SQLite 并作为可选词表使用。 支持通过设置窗口管理词表、设置切换间隔、删除词表与制作 JSON 文件。 使用多线程处理长耗时操作（导入、加载词表、托盘）以保证 UI 不阻塞。 快速开始 安装依赖（示例）： 1 pip install customtkinter pystray pillow 注意：customtkinter 依赖 tkinter（通常随 Python 自带），若缺少请安装对应系统包。\n将代码保存为 word_clock.py，并确保同目录下有 单词.db（或指定其他路径）。 运行： 1 python word_clock.py 第一次运行会生成 settings.json（默认 intervaltime = 5 秒），可在设置窗口调整。 环境依赖 Python 3.8+ tkinter（GUI） customtkinter pystray pillow (PIL) sqlite3（Python 标准库） 平台注意：代码中使用了 Windows 特定的 Win32 API（通过 ctypes）来隐藏任务栏图标，因此最佳运行环境为 Windows。在非 Windows 系统上应移除或条件兼容该部分。\n文件结构 假设单文件项目：\n1 2 3 wordcard.py 单词.db # SQLite 数据库（可选，程序会尝试连接） settings.json # 程序运行后生成或更新 导入的 JSON 文件示例（每个元素为对象）：\n1 2 3 4 [ {\u0026#34;word\u0026#34;: \u0026#34;apple\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;苹果\u0026#34;}, {\u0026#34;word\u0026#34;: \u0026#34;book\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;书\u0026#34;} ] 主要类与方法说明 WordClock (继承自 ctk.CTk) 描述：应用的主窗口类，封装 UI、数据库连接、托盘、线程与设置保存。\n属性（重要） SETTINGS_FILE：字符串，默认 settings.json。 db_path：SQLite 数据库路径，默认 单词.db。 db_conn, db_cursor：数据库连接与游标（持久连接，check_same_thread=False）。 wordtables：从 SQLite 读取到的表名列表。 words_list：当前选中词表对应的单词列表，元素为 (word, translate)。 intervaltime：单词切换时间间隔（秒）。 running：布尔，控制自动更新线程运行。 loading：布尔，指示是否处于词表加载中，用于暂停自动刷新。 方法摘要（按功能分组） 初始化与窗口配置 __init__(self, db_path=\u0026quot;单词.db\u0026quot;)：创建窗口、加载配置、打开数据库连接、启动托盘线程与自动刷新线程、绑定关闭事件等。 hide_from_taskbar(self)：使用 ctypes 调用 Win32 API 将窗口从任务栏隐藏（Windows-specific）。 bind_drag_events(self)、start_drag、on_drag：支持拖动并在拖动时保存位置。 设置存取 load_settings(self)：读取 settings.json，若不存在返回默认配置。 save_settings(self)：保存窗口位置、当前选表名、间隔等到 settings.json。 on_close(self)：窗口关闭回调，保存设置并退出。 数据库与数据加载 fetch_wordtables(self, db_path)：读取 SQLite 中的表名并存入 self.wordtables。SQL 为 SELECT name FROM sqlite_master WHERE type='table' ORDER BY rowid;。 load_words_from_db(self, db_path, table_name=None)：读取指定表的 word, translate 列并返回列表；若未传表名，默认取 self.wordtables[0]。 json2sqldb(self, file_address, file_name)：将 JSON 数据写入新建的 SQLite 表，包含事务优化（调整 PRAGMA、BEGIN TRANSACTION、executemany、commit），最后恢复 PRAGMA 设置。 自动切换与UI更新 auto_update_words(self)：后台线程循环，根据 self.intervaltime 随机选择单词并通过 after(0, ...) 回到主线程更新 UI。会在 self.loading=True 时短暂等待以避免冲突。 display_translation(self, text)：当翻译过长时设置 wraplength 以换行显示。 托盘相关 setup_tray(self)：构造托盘图标与菜单（显示/隐藏、设置、退出），并运行事件循环（pystray）。独立线程运行。 toggle_window(self, icon=None, item=None)：切换窗口显示/隐藏。 quit_app(self, icon=None, item=None)：停止线程、关闭数据库并退出。 设置窗口与词表管理 so_setting(self)：打开设置窗口，构建左侧控制按钮与右侧显示词表的滚动区域，并异步加载表名。 load_wordtables_async(self)：后台加载表并回调 put_tables_on_right。 put_tables_on_right(self)：基于 self.wordtables 在滚动区构建按钮并支持高亮当前表。 on_label_click_with_confirmation(self, name, button)：点击某个词表按钮弹出确认框，确认后显示遮罩并在后台加载数据，加载完成后更新 UI 与当前表。 del_wordtable(self) / confirm_delete(self, table_name, popup)：删除选中表并刷新 UI。 open_make_wordtable_window(self) / generate_json_from_text(self, text_box, win)：允许用户粘贴文本快速生成 JSON 文件（每行 单词 翻译），并保存 JSON。 加载遮罩与动画 _create_loading_overlay(self, message=\u0026quot;正在加载…\u0026quot;)：在 main_frame 上创建覆盖层（遮罩）并返回 overlay。 _start_loading_animation(self, overlay)：使用 after 循环更新点点动画，直至 self.loading=False。 _stop_loading_animation(self)：取消动画任务。 辅助弹窗 show_popup(self, message: str, duration: int = 1800)：自定义 CTkToplevel 弹窗，代替未加载的 CTkMessagebox。 数据库与数据格式 SQLite 表结构（在 json2sqldb 创建） 1 2 3 4 5 CREATE TABLE \u0026lt;table_name\u0026gt; ( id INTEGER PRIMARY KEY AUTOINCREMENT, word varchar(255) NULL DEFAULT NULL, translate TEXT NULL ); JSON 导入格式：数组，每项为对象：{\u0026quot;word\u0026quot;: \u0026quot;xxx\u0026quot;, \u0026quot;translate\u0026quot;: \u0026quot;yyy\u0026quot;}。 注意：代码假设表中存在 word 与 translate 字段。若你的原始表结构不同，需修改 load_words_from_db 查询语句。 设置与持久化（settings.json） settings.json 存储字段：\npos_x、pos_y：上次窗口位置（像素坐标）。 last_table：上次使用的词表名。 intervaltime：单词自动切换间隔（秒）。 默认文件会在程序首次运行时创建（intervaltime=5）。保存由 save_settings() 完成（拖动、修改间隔、关闭时等触发）。\n运行与调试建议 数据库无法连接：确认 db_path 路径正确且文件存在。若数据库为空，程序的 fetch_wordtables 可能返回空列表，load_words_from_db 会返回占位 (\u0026quot;No word\u0026quot;,\u0026quot;无\u0026quot;)。 线程安全：使用了 sqlite3.connect(..., check_same_thread=False) 来允许多线程访问。但推荐仅主线程使用游标并在子线程使用新的连接（sqlite3.connect(self.db_path)）以避免潜在竞态。 托盘图标不显示或程序无反应：pystray 在某些平台或环境需要额外配置。测试时可先注释 setup_tray 并直接运行主窗口检查 UI。 隐藏任务栏仅在 Windows 生效：hide_from_taskbar() 使用 Win32 API，仅在 Windows 上有效，跨平台请条件判断或移除。 日志与异常：建议扩展 print 为 logging 模块，并在关键异常中记录堆栈信息以便排查。 常见问题与解决方法 问：窗口没有显示单词或只显示 No word。 因为数据库中没有表或表中没有数据。确保通过导入 JSON 创建了至少一个表或手动向 SQLite 中插入数据。 问：点击词表按钮没反应。 检查 word_table_buttons 是否正确生成，以及 self.wordtables 是否有数据。 问：应用未隐藏到系统托盘或无法退出。 检查 pystray 是否正常安装并且在当前平台支持托盘操作。临时方法：直接关闭窗口或在代码中调用 quit_app()。 扩展与改进建议 使用线程池/Executor：替换原始 threading.Thread 为 concurrent.futures.ThreadPoolExecutor 以更好地管理线程生命周期与异常捕获。 数据库连接策略：将长期持久连接改为“按线程新建连接”的策略（每个线程独立连接），以避免跨线程共享同一游标导致的问题。 UI 优化：为长文本增加动效、增加单词发音（调用 TTS 或在线 API）、支持多语言界面切换。 配置界面改进：在设置窗口直接显示并编辑 intervaltime，支持导入 CSV、 Excel；提供词表导出功能（JSON / CSV）。 跨平台兼容：为 hide_from_taskbar 添加平台判断，并实现 macOS / Linux 下替代实现或跳过该功能。 错误日志：集成日志文件输出以及可选的错误上报（不建议在个人项目中默认开启）。 附：典型 JSON 输入示例 1 2 3 4 5 [ {\u0026#34;word\u0026#34;: \u0026#34;apple\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;苹果\u0026#34;}, {\u0026#34;word\u0026#34;: \u0026#34;book\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;书\u0026#34;}, {\u0026#34;word\u0026#34;: \u0026#34;computer\u0026#34;, \u0026#34;translate\u0026#34;: \u0026#34;电脑 计算机\u0026#34;} ] ","date":"2025-10-17T14:53:54+08:00","image":"https://Entars.github.io/p/wordcard%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/1_hu_1e2100ef79013217.jpg","permalink":"https://Entars.github.io/p/wordcard%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/","title":"WordCard技术文档"},{"content":"打开数据库 使用SQLite3创建数据的连接，当数据库文件存在则连接对象直接打开数据库文件，不存在则自动创建数据库文件。连接对象可以是硬盘上面的数据库文件，也可以是建立在内存（memory）中的，在内存中的数据库执行完任何操作后，都不需要提交事务的(commit)\nSQLite3的connect方法返回con对象，即数据库连接对象，提供如下方法：\n方法 描述 .cursor() 创建一个游标对象 .commit() 处理事务提交 .rollback() 处理事务回滚 .close() 关闭一个数据库连接 创建数据库 在硬盘上建立数据库 1 con=sqlite3.connect(\u0026#34;E:\\Test.db\u0026#34;) 路径中单斜杠和双斜杠不做区分，且数据库的名称不区分大小写，即E:\\Test.db 与 E:\\\\Test.db 与 E:\\TEST.db 均相同。 但需要注意的是： E:\\test.db 会报错，因为编译器会识别到 \\t 为制表符，因此认为路径不对。\n1 con=sqlite3.connect(\u0026#34;Test.db\u0026#34;) 不加全路径则在项目文件下创建数据库\n在内存上创建数据库 1 con=sqlite3.connect(\u0026#34;memory\u0026#34;) 两者差别 追求极致速度和临时性就选内存数据库；需要数据持久保存、大容量或共享访问则选文件数据库。\n混合模式可以兼顾两者优点：你可以将整个文件数据库附加 (ATTACH) 到内存数据库中进行高速操作，处理完成后再将结果写回磁盘文件。这适合“热数据”需要内存加速，而“冷数据”需要持久化的复杂场景\n创建游标 游标对象是数据库管理系统提供的一种数据访问机制，它就像一个指向查询结果集的指针，允许你逐行处理数据，而不是一次性操作整个结果集\n方法 描述 .execute() 用来执行SQL语句 .executemany() 批量执行同一条SQL语句 .close() 用来关闭游标 .fetchone() 从查询结果中获取下一行数据 .fetchmany() 从结果中取出多条记录 .fetchall() 取出所有剩余记录 .scroll() 用于游标滚动 执行SQL语句 创建表 1 cur.execute(\u0026#34;CREATE TABLE IF NOT EXISTS test(id INTEGER PRIMARY KEY,name TEXT,age INTEGER)\u0026#34;) 新增数据 方法一\n1 2 data = \u0026#34;5,\u0026#39;leon\u0026#39;,22\u0026#34; cur.execute(\u0026#39;INSERT INTO test VALUES (%s)\u0026#39;%data) 方法二\n1 cur.execute(\u0026#34;INSERT INTO test values(?,?,?)\u0026#34;,(6,\u0026#34;zgq\u0026#34;,20)) 方法三\n1 cur.executemany(\u0026#39;INSERT INTO test VALUES (?,?,?)\u0026#39;,[(3,\u0026#39;name3\u0026#39;,19),(4,\u0026#39;name4\u0026#39;,26)]) 更新数据 方法一\n1 cur.execute(\u0026#34;UPDATE test SET name=? WHERE id=?\u0026#34;,(\u0026#34;nihao\u0026#34;,1)) 方法二\n1 cur.execute(\u0026#34;UPDATE test SET name=\u0026#39;haha\u0026#39; WHERE id=1\u0026#34;) 删除数据 方法一\n1 n=cur.execute(\u0026#34;DELETE FROM test WHERE id=?\u0026#34;,(1,)) 方法二\n1 n=cur.execute(\u0026#34;DELETE FROM test WHERE id=1\u0026#34;) 返回的n为被删除的对象\n查询数据 1 cur.execute(\u0026#34;SELECT * FROM test\u0026#34;) 查询结果存储在游标对象cur中，可以使用对象的方法进行访问，例如遍历或使用.fetchone()等方法\n删除表 1 cur.execute(\u0026#34;DROP TABLE Test \u0026#34;) 事务回滚或提交 提交\n1 con.commit() 回滚\n1 con.rollback() 关闭数据库和游标\n1 2 cur.close() con.close() 一定要先关闭游标，再关闭数据库连接，否则会报错\n案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 import sqlite3 # 连接到内存数据库并创建游标对象 conn = sqlite3.connect(\u0026#39;:memory:\u0026#39;) cursor = conn.cursor() print(\u0026#34;=== 1. 使用 .execute() 创建表并插入单条数据 ===\\n\u0026#34;) # .execute(): 执行一条SQL语句来创建表 create_table_sql = \u0026#34;\u0026#34;\u0026#34; CREATE IF NOT EXISTS EXISTS users ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, age INTEGER ) \u0026#34;\u0026#34;\u0026#34; cursor.execute(create_table_sql) # .execute(): 执行一条INSERT语句插入单条数据 insert_sql = \u0026#34;INSERT INTO users (name, age) VALUES (?, ?)\u0026#34; cursor.execute(insert_sql, (\u0026#39;Alice\u0026#39;, 25)) print(f\u0026#34;插入单条数据，受影响的行数: {cursor.rowcount}\u0026#34;) print(\u0026#34;\\n=== 2. 使用 .executemany() 批量插入数据 ===\\n\u0026#34;) # .executemany(): 执行同一条SQL语句，但传入多组参数 users_data = [ (\u0026#39;Bob\u0026#39;, 30), (\u0026#39;Charlie\u0026#39;, 35), (\u0026#39;Diana\u0026#39;, 28), (\u0026#39;Evan\u0026#39;, 40) ] cursor.executemany(insert_sql, users_data) print(f\u0026#34;批量插入数据，受影响的行数: {cursor.rowcount}\u0026#34;) # 提交事务，使插入的数据生效 conn.commit() print(\u0026#34;\\n=== 3. 使用 .fetch*() 系列方法查询数据 ===\\n\u0026#34;) # .execute(): 执行查询语句 cursor.execute(\u0026#34;SELECT * FROM users ORDER BY id\u0026#34;) print(\u0026#34;--- 使用 .fetchone() 逐条获取 ---\u0026#34;) # .fetchone(): 获取结果集中的下一行 first_row = cursor.fetchone() print(f\u0026#34;第一条记录: {first_row}\u0026#34;) second_row = cursor.fetchone() print(f\u0026#34;第二条记录: {second_row}\u0026#34;) print(\u0026#34;\\n--- 使用 .fetchmany() 获取指定数量的记录 ---\u0026#34;) # .fetchmany(size): 获取指定数量的行 # 注意：此时游标指向第三条记录 next_few_rows = cursor.fetchmany(2) # 获取接下来的2条记录 print(f\u0026#34;接下来的两条记录: {next_few_rows}\u0026#34;) print(\u0026#34;\\n--- 使用 .fetchall() 获取所有剩余记录 ---\u0026#34;) # .fetchall(): 获取结果集中所有剩余的行 remaining_rows = cursor.fetchall() print(f\u0026#34;所有剩余记录: {remaining_rows}\u0026#34;) # 再次执行查询，让游标回到结果集开头 cursor.execute(\u0026#34;SELECT * FROM users ORDER BY id\u0026#34;) all_rows = cursor.fetchall() print(f\u0026#34;\\n--- 使用 .fetchall() 获取全部记录 ---\u0026#34;) print(f\u0026#34;全部记录: {all_rows}\u0026#34;) print(\u0026#34;\\n=== 4. 使用 .scroll() 滚动游标 ===\\n\u0026#34;) # 为了演示.scroll()，我们重新执行查询 cursor.execute(\u0026#34;SELECT * FROM users ORDER BY id\u0026#34;) # .scroll(value, mode=\u0026#39;relative\u0026#39;): 相对当前位置移动游标 cursor.fetchone() # 先读取第一条，游标到第二条 print(f\u0026#34;读取第一条后，当前游标位置在第二条\u0026#34;) # 相对移动：从当前位置向后移动2条记录 cursor.scroll(2, mode=\u0026#39;relative\u0026#39;) row_after_scroll = cursor.fetchone() print(f\u0026#34;相对当前位置向后滚动2条后，读取的记录是: {row_after_scroll}\u0026#34;) # 应该是第5条 # .scroll(value, mode=\u0026#39;absolute\u0026#39;): 移动到结果集的绝对位置 cursor.scroll(0, mode=\u0026#39;absolute\u0026#39;) # 滚动到开头（第0条，但索引从0开始） first_row_again = cursor.fetchone() print(f\u0026#34;绝对滚动到开头后，读取的记录是: {first_row_again}\u0026#34;) # 应该是第1条 print(\u0026#34;\\n=== 5. 使用 .close() 关闭游标 ===\\n\u0026#34;) # .close(): 关闭游标，释放资源 print(f\u0026#34;关闭前，游标状态: {not cursor.closed}\u0026#34;) # False 表示未关闭 cursor.close() print(f\u0026#34;关闭后，游标状态: {cursor.closed}\u0026#34;) # True 表示已关闭 # 关闭数据库连接 conn.close() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 === 1. 使用 .execute() 创建表并插入单条数据 === 插入单条数据，受影响的行数: 1 === 2. 使用 .executemany() 批量插入数据 === 批量插入数据，受影响的行数: 4 === 3. 使用 .fetch*() 系列方法查询数据 === --- 使用 .fetchone() 逐条获取 --- 第一条记录: (1, \u0026#39;Alice\u0026#39;, 25) 第二条记录: (2, \u0026#39;Bob\u0026#39;, 30) --- 使用 .fetchmany() 获取指定数量的记录 --- 接下来的两条记录: [(3, \u0026#39;Charlie\u0026#39;, 35), (4, \u0026#39;Diana\u0026#39;, 28)] --- 使用 .fetchall() 获取所有剩余记录 --- 所有剩余记录: [(5, \u0026#39;Evan\u0026#39;, 40)] --- 使用 .fetchall() 获取全部记录 --- 全部记录: [(1, \u0026#39;Alice\u0026#39;, 25), (2, \u0026#39;Bob\u0026#39;, 30), (3, \u0026#39;Charlie\u0026#39;, 35), (4, \u0026#39;Diana\u0026#39;, 28), (5, \u0026#39;Evan\u0026#39;, 40)] === 4. 使用 .scroll() 滚动游标 === 读取第一条后，当前游标位置在第二条 相对当前位置向后滚动2条后，读取的记录是: (5, \u0026#39;Evan\u0026#39;, 40) 绝对滚动到开头后，读取的记录是: (1, \u0026#39;Alice\u0026#39;, 25) === 5. 使用 .close() 关闭游标 === 关闭前，游标状态: True 关闭后，游标状态: False ","date":"2025-10-11T15:16:24+08:00","image":"https://Entars.github.io/p/sqlite3/1_hu_a52b207ed9ff498b.jpg","permalink":"https://Entars.github.io/p/sqlite3/","title":"SQLite3"},{"content":"滤波器的本质 其本质是一种特殊的函数，即在图像的局部区域用提供的明确计算方法对区内的像素值进行计算，用最后的计算结果替代该局部区域的中心值。 $$ V=G(X,W) $$ 其中X是矩阵（局部区域），W是向量（计算权重）\n滤波器的几种大类型 线性滤波器：即对矩阵直接加权求和，G(X,W)=X·W 非线性滤波器：不满足线性滤波器要求的，即为非线性滤波器，典型的有最大值/最小值/均值 自适应滤波器：线性滤波中的W在滑动过程中固定不变，自适应滤波的W则是在滑动过程中会随着窗口内像素的性质和结构发生变化。但计算代价更高更难优化加速 图像滤波器 1.平滑滤波器 均值滤波、中值滤波、高斯滤波的基本原理都是滑动窗口，以指定的计算方式得到其中的值\n1.1高斯滤波 高斯滤波器使图像平滑，用于去除噪声。主要计算方法是将中心像素的周围像素按照高斯分布加权平均进行平滑化，这种二维权值通常被称为卷积核或滤波器。 $$ f(x,y)=\\frac{1}{2Π\\sigma ^{2} } e^{-\\frac{x^{2}+y^{2} }{2\\sigma ^{2} } } $$1.2中值滤波 中值滤波是取滑动窗口中像素的最大值 $$ \\begin{pmatrix} 1\u0026 2 \u0026 3\\\\ 4\u0026 5\u00266 \\\\ 7\u0026 {\\color{Red} 8} \u00267 \\end{pmatrix} $$1.3均值滤波 取滑动窗口中的均值，该滤波器对减少图像中的随机噪声有效\n2.边缘检测滤波器 边缘检测目的是标识数字图像中亮度变化明显的点，提取图像中的线条，该种检测常在灰度图中进行\n2.1 Prewitt滤波器 该滤波器的设计思想是真正的边界点在水平方向和垂直方向上的相邻点应该也同样为边界点，因此以更大的边缘检测滤波器，考虑周围更多的点会使得边缘检测更准确。算子模板有： $$ G_{X}= \\begin{pmatrix} -1\u0026 0 \u0026 1\\\\ -1\u0026 0\u00261 \\\\ -1\u0026 0 \u00261 \\end{pmatrix},G_{Y}=\\begin{pmatrix} -1 \u0026 -1 \u0026-1\\\\ 0\u0026 0 \u00260\\\\ 1\u00261\u00261 \\end{pmatrix} $$ 计算方法是卷积。\n2.2 Sobel滤波器 Sobel算子在Prewitt算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓。算子模板： $$ G_{X}= \\begin{pmatrix} -1\u0026 0 \u00261\\\\ -2\u0026 0 \u00262 \\\\ -1\u0026 0 \u00261 \\end{pmatrix},G_{Y}=\\begin{pmatrix} -1 \u0026 -2 \u0026-1\\\\ 0 \u0026 0 \u00260\\\\ 1 \u0026 2 \u0026 1 \\end{pmatrix} $$2.3 Laplacian滤波器 前面两种是一阶微分，而Laplacian滤波器则是二阶微分滤波器。其推导过程为： 一阶差分：\n$$ \\begin{aligned} I_{x}(x,y) \u0026= I(x+1,y) - I(x,y), \\\\ I_{y}(x,y) \u0026= I(x,y+1) - I(x,y). \\end{aligned} $$二阶差分：\n$$ \\begin{aligned} I_{xx}(x,y) \u0026= I(x+2,y) - 2I(x+1,y) + I(x,y) \\\\ \u0026= I(x+1,y) - 2I(x,y) + I(x-1,y), \\\\ I_{yy}(x,y) \u0026= I(x,y+1) - 2I(x,y) + I(x,y-1). \\end{aligned} $$因此拉普拉斯算子为：\n$$ \\nabla^2 I(x,y) = I_{xx}(x,y) + I_{yy}(x,y). $$其卷积核为（四邻域模板）：\n$$ \\begin{pmatrix} 0 \u0026 \\;1 \u0026 0 \\\\ 1 \u0026 -4 \u0026 1 \\\\ 0 \u0026 \\;1 \u0026 0 \\end{pmatrix} $$八邻域模板为：\n$$ \\begin{pmatrix} 1 \u0026 1 \u0026 1 \\\\ 1 \u0026 -8 \u0026 1 \\\\ 1 \u0026 1 \u0026 1 \\end{pmatrix} $$算法基本流程为:\n判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作;\n在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系；\n最后通过梯度运算的结果对像素灰度进行调整。\n基本规律：\n当邻域内像素灰度相同时，模板的卷积运算结果为0；\n当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；\n当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。\n2.4MAX-MIN滤波器 MAX-MIN滤波器是一种常见的边缘检测滤波器，其使用网格内像素的最大值和最小值的差值对网格内像素重新赋值。\n","date":"2025-09-14T01:14:13+08:00","image":"https://Entars.github.io/p/%E6%BB%A4%E6%B3%A2%E5%99%A8/0_hu_bc6e1f7733c07716.jpg","permalink":"https://Entars.github.io/p/%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"滤波器"},{"content":"PyQt5能干什么 ​\tPyQt5的主要作用是创建UI界面，同时支持鼠标以及键盘的交互，不仅提供界面控件，还提供网络、数据库、多媒体等应用开发功能，具体来说：\nUI控件（Widgets）： 最基础也是最重要的，提供大量开箱即用的的UI元素，可以像搭积木一样构建界面\n基础控件：按钮（QPushButton）、标签（QLabel）、文本框（QLineEdit）、文本域（QTextEdit）、组合框（QComboBox）、列表（QListWidget）、表格（QTableWidget）等。 布局管理器：水平布局（QHBoxLayout）、垂直布局（QVBoxLayout）、网格布局（QGridLayout）等，用于自动排列和调整控件大小，确保窗口缩放时界面依然美观。 高级容器：选项卡（QTabWidget）、分组框（QGroupBox）、滚动区域（QScrollArea）、堆叠窗口（QStackedWidget）、停靠窗口（QDockWidget）等，用于组织复杂的界面结构。 主窗口框架：QMainWindow 类提供了标准应用程序主窗口的功能，包括菜单栏（QMenuBar）、工具栏（QToolBar）、状态栏（QStatusBar）和中心部件。 图形与视图框架： 处理大量的、交互式的2D图形对象，适合开发绘图软件、数据可视化、游戏编辑器。核心组件有：QGraphicsScene（场景，管理所有图形项）、QGraphicsView（视图，用于显示场景）、QGraphicsItem（图形项，如矩形、椭圆、自定义图形）\n多媒体功能 音频播放：使用 QMediaPlayer 和 QAudioOutput 播放音频文件。 视频播放：使用 QMediaPlayer 和 QVideoWidget 播放视频文件。 摄像头访问：使用 QCamera 来捕获实时摄像头画面。 网络功能 HTTP/HTTPS 请求：通过 QNetworkAccessManager 进行网络通信，支持 GET、POST 等操作，比 Python 标准的 urllib 更强大、更易用。 TCP/UDP 通信：提供了 QTcpSocket, QTcpServer, QUdpSocket 等类，用于开发低层的网络应用，如聊天程序、自定义协议客户端/服务器。 WebSocket：支持现代 WebSocket 协议。 数据库连接 通过 QtSql 模块提供了统一的接口来操作各种数据库，如 SQLite、MySQL、PostgreSQL、ODBC 等。 内置了非常方便的模型/视图类（如 QSqlTableModel），可以轻松地将数据库中的表与UI控件（如 QTableView）绑定，实现数据的自动显示和编辑。 多线程（QThread） 桌面应用的UI主线程必须保持响应，否则会“卡住”。PyQt5 提供了 QThread 类，可以轻松地将耗时的操作（如下载文件、复杂计算）放到子线程中运行，并通过信号（Signal）与槽（Slot） 机制与主线程通信，更新UI进度，保证程序的流畅性\n样式与主题（QSS - Qt Style Sheets） 类似于 Web 开发中的 CSS，你可以使用 QSS 来极大地美化应用程序的界面，可以轻松地自定义控件的外观、颜色、字体、边框、背景等，从而打造出独一无二的、现代化的UI风格，而无需修改代码逻辑\n基本控件介绍 QMainWindow： 主窗口类（主界面），可以包含菜单栏、工具栏、状态栏、中心窗口等各种窗口部件，其中中心窗口是最重要的，可以是任何Qt窗口部件，常用成员函数：\nsetCentralWidget():设置中心窗口部件 setMenuBar():设置菜单栏 addToolBar():添加工具栏 statusBar():获取状态栏 show():显示主窗口 Qwidget: 是Qt框架中所有用户界面的基类，包括窗口、对话框、按钮、标签、文本框等，此外还提供一些基本的用户界面功能，例如绘制、事件处理、布局等。\nQWidget提供了一些常用的属性和方法，例如size()、pos()、setWindowTitle()等，以便于管理和操作界面部件。\n在创建自定义用户界面部件时，我们可以从QWidget派生出我们自己的部件类，并通过重载其成员函数来实现自定义行为。例如，我们可以通过重载QWidget的paintEvent()函数来绘制自己的部件，或者通过重载其mousePressEvent()函数来处理鼠标点击事件\nQMain Window、Qwidget、QDialog的区别：\nQDialog: 是对话窗口的基类，没有菜单栏、工具栏、状态栏。 QMainWindow：可以包含菜单栏、工具栏、状态栏和标题栏，是最常见的形式。 QWidget: 不确定窗口的用途，就使用Qwidget。\nSpacers控件 用于布局的空白控件，在布局中创建空白区域来分隔其它控件，空白区域的大小由其内部设置size_policy控制。\n该控件有两种类型：水平（QSpacerItem）和垂直（QSpacerItem），可以使用QHBoxLayout或QVBoxLayout将Spacer控件添加到布局中。在添加Spacer控件时，您可以指定其最小大小、最大大小和首选大小，以及其大小策略\nQlabel控件 显示文本或图像的控件，它通常被用于显示静态文本信息，可以通过设置其文本、字体、颜色、对齐方式等属性来自定义标签的样式和布局。可以将QLabel放置在主窗口、对话框或其他控件上，以便在应用程序中提供帮助文本、说明、状态消息等。\n方法： setText(text): 设置文本内容\nsetPixmap(pixmap): 设置图像内容\nsetAlignment(alignment): 设置文本或图像的对齐方式\nsetWordWrap( on): 当文本过长时是否自动换行\nsetFixedSize(width, height): 设置控件的固定大小\nsetStyleSheet(styleSheet): 设置控件的样式表\n属性： text(): 返回控件的文本内容 pixmap(): 返回控件的图像内容 alignment(): 返回控件的对齐方式 wordWrap(): 返回控件是否自动换行 font(): 返回控件的字体 color(): 返回控件的颜色 常用信号： linkActivated:当控件中包含超链接时，用户单击链接时触发此信号。 linkHovered:当用户将鼠标悬停在超链接上时，触发此信号。 linkPressed:当用户按下并释放鼠标按钮时，同时鼠标位于超链接上时，触发此信号。 综合案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 import sys from PyQt5.QtWidgets import (QApplication, QWidget, QLabel, QVBoxLayout, QLineEdit, QPushButton, QHBoxLayout, QFrame) from PyQt5.QtCore import Qt, QTimer, pyqtSignal from PyQt5.QtGui import QFont, QPalette, QColor, QPixmap, QLinearGradient, QBrush # 自定义可点击QLabel（支持点击信号） class ClickableLabel(QLabel): clicked = pyqtSignal() # 自定义点击信号 def __init__(self, text=\u0026#34;\u0026#34;, parent=None): super().__init__(text, parent) self.setCursor(Qt.PointingHandCursor) # 设置手型光标 def mousePressEvent(self, event): if event.button() == Qt.LeftButton: self.clicked.emit() # 发射信号 super().mousePressEvent(event) class IntegratedDemo(QWidget): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;QLabel功能集成示例\u0026#34;) self.setGeometry(300, 300, 600, 500) self.initUI() def initUI(self): main_layout = QVBoxLayout() # ===== 1. 基础属性展示 ===== frame1 = QFrame() frame1.setFrameShape(QFrame.Box) layout1 = QVBoxLayout() label_base = QLabel(\u0026#34;基础属性示例：自定义字体/颜色/对齐\u0026#34;) label_base.setFont(QFont(\u0026#34;微软雅黑\u0026#34;, 12, QFont.Bold)) label_base.setStyleSheet(\u0026#34;color: #FF0000; background-color: #FFFFCC;\u0026#34;) label_base.setAlignment(Qt.AlignCenter) label_base.setFixedHeight(40) layout1.addWidget(label_base) frame1.setLayout(layout1) main_layout.addWidget(frame1) # ===== 2. 交互功能区域 ===== frame2 = QFrame() frame2.setFrameShape(QFrame.Box) layout2 = QVBoxLayout() # 超链接交互 link_label = QLabel(\u0026#39;\u0026lt;a href=\u0026#34;https://www.qt.io\u0026#34;\u0026gt;访问Qt官网（悬停提示）\u0026lt;/a\u0026gt;\u0026#39;) link_label.setToolTip(\u0026#34;点击打开Qt官方网站\u0026#34;) link_label.linkHovered.connect(lambda link: print(f\u0026#34;链接悬停: {link}\u0026#34;)) link_label.linkActivated.connect(self.open_link) # 自定义点击标签 click_label = ClickableLabel(\u0026#34;✨ 点我切换颜色（可点击标签）\u0026#34;) click_label.setStyleSheet(\u0026#34;border: 2px solid #9999FF; padding: 10px;\u0026#34;) click_label.clicked.connect(self.toggle_label_color) layout2.addWidget(QLabel(\u0026#34;交互功能区域：\u0026#34;)) layout2.addWidget(link_label) layout2.addWidget(click_label) frame2.setLayout(layout2) main_layout.addWidget(frame2) # ===== 3. 实时同步区域 ===== frame3 = QFrame() frame3.setFrameShape(QFrame.Box) layout3 = QVBoxLayout() self.sync_lineedit = QLineEdit() self.sync_label = QLabel(\u0026#34;同步显示文本\u0026#34;) # 实时连接信号与槽 self.sync_lineedit.textChanged.connect(self.sync_label.setText) layout3.addWidget(QLabel(\u0026#34;实时同步：输入即更新\u0026#34;)) layout3.addWidget(self.sync_lineedit) layout3.addWidget(self.sync_label) frame3.setLayout(layout3) main_layout.addWidget(frame3) # ===== 4. 动态效果区域 ===== frame4 = QFrame() frame4.setFrameShape(QFrame.Box) layout4 = QVBoxLayout() # 充电进度效果 self.charge_label = QLabel() self.charge_label.setFixedHeight(30) self.charge_label.setText(\u0026#34;充电中: 0%\u0026#34;) self.charge_label.setAlignment(Qt.AlignCenter) # 点击变色效果 self.color_label = QLabel(\u0026#34;点击下方按钮变色\u0026#34;) self.color_label.setAlignment(Qt.AlignCenter) self.color_label.setFixedHeight(50) # 控制按钮 btn_toggle = QPushButton(\u0026#34;启动充电动画\u0026#34;) btn_toggle.clicked.connect(self.toggle_charge_animation) btn_color = QPushButton(\u0026#34;随机颜色\u0026#34;) btn_color.clicked.connect(self.change_random_color) btn_layout = QHBoxLayout() btn_layout.addWidget(btn_toggle) btn_layout.addWidget(btn_color) layout4.addWidget(QLabel(\u0026#34;动态效果区域：\u0026#34;)) layout4.addWidget(self.charge_label) layout4.addWidget(self.color_label) layout4.addLayout(btn_layout) frame4.setLayout(layout4) main_layout.addWidget(frame4) self.setLayout(main_layout) # 充电动画控制 self.charge_timer = QTimer() self.charge_timer.timeout.connect(self.update_charge) self.charge_percent = 0 self.is_charging = False # ===== 功能实现方法 ===== def open_link(self, url): print(f\u0026#34;打开链接: {url}\u0026#34;) # 实际应用中可用QDesktopServices打开[1](@ref) def toggle_label_color(self): current_color = self.sender().palette().color(QPalette.Window) new_color = QColor(\u0026#34;#FFCCFF\u0026#34;) if current_color != QColor(\u0026#34;#FFCCFF\u0026#34;) else QColor(\u0026#34;#CCFFFF\u0026#34;) self.sender().setStyleSheet(f\u0026#34;background-color: {new_color.name()};\u0026#34;) print(\u0026#34;标签点击事件触发\u0026#34;) def toggle_charge_animation(self): if not self.is_charging: self.charge_timer.start(200) # 每200ms更新 self.is_charging = True else: self.charge_timer.stop() self.is_charging = False def update_charge(self): self.charge_percent = (self.charge_percent + 5) % 105 if self.charge_percent \u0026gt; 100: self.charge_label.setText(\u0026#34;充电完成!\u0026#34;) self.charge_timer.stop() self.is_charging = False return # 创建渐变进度条 gradient = QLinearGradient(0, 0, self.charge_label.width(), 0) gradient.setColorAt(0, \u0026#34;#00FF00\u0026#34;) gradient.setColorAt(self.charge_percent/100, \u0026#34;#00FF00\u0026#34;) gradient.setColorAt(min(1.0, self.charge_percent/100 + 0.01), \u0026#34;#CCCCCC\u0026#34;) # 应用渐变背景 palette = self.charge_label.palette() palette.setBrush(QPalette.Window, QBrush(gradient)) self.charge_label.setPalette(palette) self.charge_label.setText(f\u0026#34;充电中: {self.charge_percent}%\u0026#34;) def change_random_color(self): color = QColor(randint(0,255), randint(0,255), randint(0,255)) self.color_label.setStyleSheet(f\u0026#34;background-color: {color.name()}; color: white;\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: from random import randint app = QApplication(sys.argv) window = IntegratedDemo() window.show() sys.exit(app.exec_()) QLineEdit控件 该控件用于接收用户输入的单行文本编辑，允许输入和编辑文本信息； 同时也可以限定输入内容的形式比如只允许输入数字、字母或特定字符，或者限定输入内容长度； 可以使用信号和槽机制来处理用户输入的文本，以便在应用程序中执行特定的操作或验证用户输入的有效性。\n方法： setAlignment(alignment)：设置文本的对齐方式，alignment可以是Qt.AlignLeft、Qt.AlignRight、Qt.AlignCenter等值之一 setPlaceholderText(text)：设置控件的占位符文本，当控件没有内容时显示的文本 setReadOnly(readOnly)：设置控件是否为只读模式 setValidator(validator)：设置控件的输入验证器，用于限制用户输入的内容 textChanged.connect(slot)：文本改变时的信号，连接到相应的槽函数 属性： text()：获取或设置控件的文本内容 setText(text)：设置控件的文本内容 clear()：清空控件的文本内容 综合案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 import sys from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QLineEdit, QLabel, QPushButton, QHBoxLayout, QFormLayout, QCompleter) from PyQt5.QtGui import QIntValidator, QDoubleValidator, QRegularExpressionValidator, QFont, QIcon from PyQt5.QtCore import Qt, QRegularExpression class LineEditDemo(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle(\u0026#34;QLineEdit 综合功能演示\u0026#34;) self.setGeometry(300, 300, 600, 450) layout = QVBoxLayout() # ===== 1. 基础功能区域 ===== base_layout = QFormLayout() # 基础文本输入（实时反馈） self.basic_edit = QLineEdit() self.basic_edit.setPlaceholderText(\u0026#34;输入实时显示在右侧\u0026#34;) self.basic_label = QLabel(\u0026#34;等待输入...\u0026#34;) self.basic_edit.textChanged.connect(lambda: self.basic_label.setText(self.basic_edit.text())) base_layout.addRow(\u0026#34;基础输入:\u0026#34;, self.basic_edit) base_layout.addRow(\u0026#34;实时反馈:\u0026#34;, self.basic_label) # 整数验证（范围限制） self.int_edit = QLineEdit() self.int_edit.setValidator(QIntValidator(1, 100)) # 限制1-100整数 self.int_edit.setPlaceholderText(\u0026#34;输入1-100的整数\u0026#34;) base_layout.addRow(\u0026#34;整数验证:\u0026#34;, self.int_edit) # 浮点数验证（格式限制） self.float_edit = QLineEdit() float_validator = QDoubleValidator(0.0, 100.0, 2) # 范围0-100，2位小数 float_validator.setNotation(QDoubleValidator.StandardNotation) self.float_edit.setValidator(float_validator) self.float_edit.setPlaceholderText(\u0026#34;0.00-100.00\u0026#34;) base_layout.addRow(\u0026#34;浮点数验证:\u0026#34;, self.float_edit) layout.addLayout(base_layout) # ===== 2. 高级功能区域 ===== adv_layout = QFormLayout() # 正则表达式验证（邮箱格式） self.email_edit = QLineEdit() email_regex = QRegularExpression(\u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34;) self.email_edit.setValidator(QRegularExpressionValidator(email_regex)) self.email_edit.setPlaceholderText(\u0026#34;example@domain.com\u0026#34;) adv_layout.addRow(\u0026#34;邮箱验证:\u0026#34;, self.email_edit) # 输入掩码（电话号码） self.phone_edit = QLineEdit() self.phone_edit.setInputMask(\u0026#34;999-9999-9999;#\u0026#34;) # 格式: 138-8888-8888 adv_layout.addRow(\u0026#34;电话掩码:\u0026#34;, self.phone_edit) # 密码输入（显示切换） self.pwd_layout = QHBoxLayout() self.pwd_edit = QLineEdit() self.pwd_edit.setEchoMode(QLineEdit.Password) self.toggle_btn = QPushButton(\u0026#34;显示\u0026#34;) self.toggle_btn.setCheckable(True) self.toggle_btn.toggled.connect(self.toggle_pwd_visibility) self.pwd_layout.addWidget(self.pwd_edit) self.pwd_layout.addWidget(self.toggle_btn) adv_layout.addRow(\u0026#34;密码输入:\u0026#34;, self.pwd_layout) # 自动补全 self.auto_edit = QLineEdit() completer = QCompleter([\u0026#34;Python\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;JavaScript\u0026#34;]) self.auto_edit.setCompleter(completer) self.auto_edit.setPlaceholderText(\u0026#34;输入编程语言\u0026#34;) adv_layout.addRow(\u0026#34;自动补全:\u0026#34;, self.auto_edit) layout.addLayout(adv_layout) # ===== 3. 交互反馈区域 ===== feedback_layout = QHBoxLayout() # 清除按钮 self.clear_edit = QLineEdit() self.clear_edit.setClearButtonEnabled(True) # 启用内置清除按钮 self.clear_edit.setPlaceholderText(\u0026#34;输入后点击右侧X清除\u0026#34;) feedback_layout.addWidget(QLabel(\u0026#34;清除按钮:\u0026#34;)) feedback_layout.addWidget(self.clear_edit) # 样式反馈 self.style_edit = QLineEdit() self.style_edit.setPlaceholderText(\u0026#34;输入\u0026#39;error\u0026#39;触发红色边框\u0026#34;) self.style_edit.textChanged.connect(self.update_style) feedback_layout.addWidget(QLabel(\u0026#34;动态样式:\u0026#34;)) feedback_layout.addWidget(self.style_edit) layout.addLayout(feedback_layout) # ===== 4. 自定义操作按钮 ===== action_layout = QHBoxLayout() self.action_edit = QLineEdit() self.action_edit.setPlaceholderText(\u0026#34;右侧按钮可转为大写\u0026#34;) # 添加自定义动作按钮 upper_btn = QPushButton(\u0026#34;⇧\u0026#34;) upper_btn.clicked.connect(lambda: self.action_edit.setText(self.action_edit.text().upper())) action_layout.addWidget(QLabel(\u0026#34;动作按钮:\u0026#34;)) action_layout.addWidget(self.action_edit) action_layout.addWidget(upper_btn) layout.addLayout(action_layout) self.setLayout(layout) # ===== 功能实现方法 ===== def toggle_pwd_visibility(self, checked): \u0026#34;\u0026#34;\u0026#34;切换密码显示/隐藏\u0026#34;\u0026#34;\u0026#34; if checked: self.pwd_edit.setEchoMode(QLineEdit.Normal) self.toggle_btn.setText(\u0026#34;隐藏\u0026#34;) else: self.pwd_edit.setEchoMode(QLineEdit.Password) self.toggle_btn.setText(\u0026#34;显示\u0026#34;) def update_style(self, text): \u0026#34;\u0026#34;\u0026#34;根据输入内容动态更新样式\u0026#34;\u0026#34;\u0026#34; if \u0026#34;error\u0026#34; in text.lower(): self.style_edit.setStyleSheet(\u0026#34;border: 2px solid red;\u0026#34;) else: self.style_edit.setStyleSheet(\u0026#34;\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) demo = LineEditDemo() demo.show() sys.exit(app.exec_()) QTextEdit 该控件可以用于显示和编辑富文本的多行文本编辑控件。它可以用于创建编辑器、日记、HTML文本查看器等。 可以在文本中插入多媒体内容，如图像、超链接、HTML表格等，并且可以在文本中使用样式来设置字体、颜色、背景、对齐等。QTextEdit还支持拼写检查、撤销/重做、自动缩进、文本选择等基本编辑功能\n综合案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 import sys from PyQt5.QtWidgets import (QApplication, QMainWindow, QTextEdit, QAction, QFileDialog, QToolBar, QStatusBar, QMessageBox, QColorDialog, QFontDialog) from PyQt5.QtGui import QTextCursor, QTextCharFormat, QFont, QTextBlockFormat, QIcon, QPixmap from PyQt5.QtCore import Qt class RichTextEditor(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;QTextEdit 综合案例 - 富文本编辑器\u0026#34;) self.setGeometry(300, 200, 900, 600) self.file_path = None self.init_ui() def init_ui(self): # ===== 1. 核心控件：QTextEdit ===== self.text_edit = QTextEdit() self.text_edit.setAcceptRichText(True) # 启用富文本支持 self.text_edit.setPlaceholderText(\u0026#34;输入内容或使用工具栏进行操作...\u0026#34;) self.setCentralWidget(self.text_edit) # ===== 2. 菜单栏 ===== self.create_menus() # ===== 3. 工具栏 ===== toolbar = QToolBar(\u0026#34;格式工具栏\u0026#34;) self.addToolBar(toolbar) # 文本样式动作 - 使用文本代替图标 bold_action = QAction(\u0026#34;B\u0026#34;, self) # 使用文本代替图标 bold_action.setToolTip(\u0026#34;加粗\u0026#34;) bold_action.triggered.connect(lambda: self.set_text_format(\u0026#34;bold\u0026#34;)) toolbar.addAction(bold_action) italic_action = QAction(\u0026#34;I\u0026#34;, self) italic_action.setToolTip(\u0026#34;斜体\u0026#34;) italic_action.triggered.connect(lambda: self.set_text_format(\u0026#34;italic\u0026#34;)) toolbar.addAction(italic_action) underline_action = QAction(\u0026#34;U\u0026#34;, self) underline_action.setToolTip(\u0026#34;下划线\u0026#34;) underline_action.triggered.connect(lambda: self.set_text_format(\u0026#34;underline\u0026#34;)) toolbar.addAction(underline_action) toolbar.addSeparator() # 字体选择 font_action = QAction(\u0026#34;字体\u0026#34;, self) font_action.triggered.connect(self.choose_font) toolbar.addAction(font_action) # 颜色选择 color_action = QAction(\u0026#34;颜色\u0026#34;, self) color_action.triggered.connect(self.choose_color) toolbar.addAction(color_action) toolbar.addSeparator() # 段落对齐 align_left = QAction(\u0026#34;左对齐\u0026#34;, self) align_left.triggered.connect(lambda: self.set_alignment(Qt.AlignLeft)) toolbar.addAction(align_left) align_center = QAction(\u0026#34;居中\u0026#34;, self) align_center.triggered.connect(lambda: self.set_alignment(Qt.AlignCenter)) toolbar.addAction(align_center) align_right = QAction(\u0026#34;右对齐\u0026#34;, self) align_right.triggered.connect(lambda: self.set_alignment(Qt.AlignRight)) toolbar.addAction(align_right) toolbar.addSeparator() # 插入功能 insert_image = QAction(\u0026#34;插入图片\u0026#34;, self) insert_image.triggered.connect(self.insert_image) toolbar.addAction(insert_image) insert_link = QAction(\u0026#34;插入链接\u0026#34;, self) insert_link.triggered.connect(self.insert_link) toolbar.addAction(insert_link) # ===== 4. 状态栏 ===== self.status_bar = QStatusBar() self.setStatusBar(self.status_bar) self.text_edit.textChanged.connect(self.update_status_bar) # ===== 5. 信号连接 ===== self.text_edit.cursorPositionChanged.connect(self.cursor_position_changed) self.text_edit.selectionChanged.connect(self.selection_changed) def create_menus(self): menubar = self.menuBar() # 文件菜单 file_menu = menubar.addMenu(\u0026#34;文件\u0026#34;) new_action = QAction(\u0026#34;新建\u0026#34;, self) new_action.setShortcut(\u0026#34;Ctrl+N\u0026#34;) new_action.triggered.connect(self.new_file) file_menu.addAction(new_action) open_action = QAction(\u0026#34;打开\u0026#34;, self) open_action.setShortcut(\u0026#34;Ctrl+O\u0026#34;) open_action.triggered.connect(self.open_file) file_menu.addAction(open_action) save_action = QAction(\u0026#34;保存\u0026#34;, self) save_action.setShortcut(\u0026#34;Ctrl+S\u0026#34;) save_action.triggered.connect(self.save_file) file_menu.addAction(save_action) save_as_action = QAction(\u0026#34;另存为\u0026#34;, self) save_as_action.triggered.connect(self.save_file_as) file_menu.addAction(save_as_action) file_menu.addSeparator() exit_action = QAction(\u0026#34;退出\u0026#34;, self) exit_action.setShortcut(\u0026#34;Ctrl+Q\u0026#34;) exit_action.triggered.connect(self.close) file_menu.addAction(exit_action) # 编辑菜单 edit_menu = menubar.addMenu(\u0026#34;编辑\u0026#34;) undo_action = QAction(\u0026#34;撤销\u0026#34;, self) undo_action.setShortcut(\u0026#34;Ctrl+Z\u0026#34;) undo_action.triggered.connect(self.text_edit.undo) edit_menu.addAction(undo_action) redo_action = QAction(\u0026#34;重做\u0026#34;, self) redo_action.setShortcut(\u0026#34;Ctrl+Y\u0026#34;) redo_action.triggered.connect(self.text_edit.redo) edit_menu.addAction(redo_action) edit_menu.addSeparator() cut_action = QAction(\u0026#34;剪切\u0026#34;, self) cut_action.setShortcut(\u0026#34;Ctrl+X\u0026#34;) cut_action.triggered.connect(self.text_edit.cut) edit_menu.addAction(cut_action) copy_action = QAction(\u0026#34;复制\u0026#34;, self) copy_action.setShortcut(\u0026#34;Ctrl+C\u0026#34;) copy_action.triggered.connect(self.text_edit.copy) edit_menu.addAction(copy_action) paste_action = QAction(\u0026#34;粘贴\u0026#34;, self) paste_action.setShortcut(\u0026#34;Ctrl+V\u0026#34;) paste_action.triggered.connect(self.text_edit.paste) edit_menu.addAction(paste_action) # 视图菜单 view_menu = menubar.addMenu(\u0026#34;视图\u0026#34;) readonly_action = QAction(\u0026#34;只读模式\u0026#34;, self, checkable=True) readonly_action.toggled.connect(self.toggle_readonly) view_menu.addAction(readonly_action) # 大文件优化功能 large_file_action = QAction(\u0026#34;加载大文件(分页)\u0026#34;, self) large_file_action.triggered.connect(self.load_large_file) view_menu.addAction(large_file_action) # ===== 功能实现方法 ===== def set_text_format(self, style): \u0026#34;\u0026#34;\u0026#34;设置文本格式（加粗/斜体/下划线）\u0026#34;\u0026#34;\u0026#34; cursor = self.text_edit.textCursor() if not cursor.hasSelection(): # 如果没有选择文本，则对即将输入的文本应用格式 format = QTextCharFormat() if style == \u0026#34;bold\u0026#34;: format.setFontWeight(QFont.Bold if not self.text_edit.fontWeight() == QFont.Bold else QFont.Normal) elif style == \u0026#34;italic\u0026#34;: format.setFontItalic(not self.text_edit.fontItalic()) elif style == \u0026#34;underline\u0026#34;: format.setFontUnderline(not self.text_edit.fontUnderline()) self.text_edit.setCurrentCharFormat(format) return fmt = QTextCharFormat() if style == \u0026#34;bold\u0026#34;: fmt.setFontWeight(QFont.Bold if not cursor.charFormat().font().bold() else QFont.Normal) elif style == \u0026#34;italic\u0026#34;: fmt.setFontItalic(not cursor.charFormat().fontItalic()) elif style == \u0026#34;underline\u0026#34;: fmt.setFontUnderline(not cursor.charFormat().fontUnderline()) cursor.mergeCharFormat(fmt) def choose_font(self): \u0026#34;\u0026#34;\u0026#34;选择字体\u0026#34;\u0026#34;\u0026#34; font, ok = QFontDialog.getFont(self.text_edit.font(), self) if ok: self.text_edit.setCurrentFont(font) def choose_color(self): \u0026#34;\u0026#34;\u0026#34;选择颜色\u0026#34;\u0026#34;\u0026#34; color = QColorDialog.getColor() if color.isValid(): self.text_edit.setTextColor(color) def set_alignment(self, alignment): \u0026#34;\u0026#34;\u0026#34;设置段落对齐方式\u0026#34;\u0026#34;\u0026#34; cursor = self.text_edit.textCursor() block_fmt = QTextBlockFormat() block_fmt.setAlignment(alignment) cursor.mergeBlockFormat(block_fmt) def insert_image(self): \u0026#34;\u0026#34;\u0026#34;插入图片到光标位置\u0026#34;\u0026#34;\u0026#34; file_path, _ = QFileDialog.getOpenFileName( self, \u0026#34;选择图片\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)\u0026#34; ) if file_path: cursor = self.text_edit.textCursor() # 使用QPixmap加载图片并插入 pixmap = QPixmap(file_path) if not pixmap.isNull(): # 缩放图片以适应编辑器宽度 pixmap = pixmap.scaledToWidth(300, Qt.SmoothTransformation) cursor.insertImage(pixmap.toImage()) def insert_link(self): \u0026#34;\u0026#34;\u0026#34;插入超链接\u0026#34;\u0026#34;\u0026#34; from PyQt5.QtWidgets import QInputDialog text, ok = QInputDialog.getText(self, \u0026#34;插入链接\u0026#34;, \u0026#34;请输入链接URL:\u0026#34;) if ok and text: cursor = self.text_edit.textCursor() # 如果选择了文本，使用选中文本作为链接文本，否则使用URL if cursor.hasSelection(): link_text = cursor.selectedText() else: link_text = text cursor.insertHtml(f\u0026#39;\u0026lt;a href=\u0026#34;{text}\u0026#34;\u0026gt;{link_text}\u0026lt;/a\u0026gt;\u0026#39;) def new_file(self): \u0026#34;\u0026#34;\u0026#34;新建文件\u0026#34;\u0026#34;\u0026#34; if self.check_unsaved_changes(): self.text_edit.clear() self.file_path = None self.setWindowTitle(\u0026#34;QTextEdit 综合案例 - 富文本编辑器\u0026#34;) def open_file(self): \u0026#34;\u0026#34;\u0026#34;打开文件\u0026#34;\u0026#34;\u0026#34; if not self.check_unsaved_changes(): return path, _ = QFileDialog.getOpenFileName( self, \u0026#34;打开文件\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;文本文件 (*.txt);;HTML文件 (*.html *.htm);;所有文件 (*)\u0026#34; ) if path: try: with open(path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: if path.endswith((\u0026#39;.html\u0026#39;, \u0026#39;.htm\u0026#39;)): self.text_edit.setHtml(f.read()) else: self.text_edit.setPlainText(f.read()) self.file_path = path self.setWindowTitle(f\u0026#34;QTextEdit 综合案例 - {path}\u0026#34;) except Exception as e: QMessageBox.critical(self, \u0026#34;打开错误\u0026#34;, f\u0026#34;打开文件时出错:\\n{str(e)}\u0026#34;) def save_file(self): \u0026#34;\u0026#34;\u0026#34;保存文件\u0026#34;\u0026#34;\u0026#34; if self.file_path: self._save_to_file(self.file_path) else: self.save_file_as() def save_file_as(self): \u0026#34;\u0026#34;\u0026#34;另存为文件\u0026#34;\u0026#34;\u0026#34; path, _ = QFileDialog.getSaveFileName( self, \u0026#34;保存文件\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;文本文件 (*.txt);;HTML文件 (*.html);;所有文件 (*)\u0026#34; ) if path: self._save_to_file(path) self.file_path = path self.setWindowTitle(f\u0026#34;QTextEdit 综合案例 - {path}\u0026#34;) def _save_to_file(self, path): \u0026#34;\u0026#34;\u0026#34;实际保存操作\u0026#34;\u0026#34;\u0026#34; try: with open(path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: if path.endswith(\u0026#39;.html\u0026#39;): f.write(self.text_edit.toHtml()) else: f.write(self.text_edit.toPlainText()) self.text_edit.document().setModified(False) self.status_bar.showMessage(f\u0026#34;文件已保存: {path}\u0026#34;, 3000) except Exception as e: QMessageBox.critical(self, \u0026#34;保存错误\u0026#34;, f\u0026#34;保存文件时出错:\\n{str(e)}\u0026#34;) def toggle_readonly(self, state): \u0026#34;\u0026#34;\u0026#34;切换只读模式\u0026#34;\u0026#34;\u0026#34; self.text_edit.setReadOnly(state) self.status_bar.showMessage(f\u0026#34;只读模式: {\u0026#39;开启\u0026#39; if state else \u0026#39;关闭\u0026#39;}\u0026#34;, 2000) def update_status_bar(self): \u0026#34;\u0026#34;\u0026#34;更新状态栏统计信息\u0026#34;\u0026#34;\u0026#34; text = self.text_edit.toPlainText() char_count = len(text) word_count = len(text.split()) line_count = self.text_edit.document().blockCount() self.status_bar.showMessage(f\u0026#34;字符: {char_count} | 单词: {word_count} | 行数: {line_count}\u0026#34;) def cursor_position_changed(self): \u0026#34;\u0026#34;\u0026#34;光标位置变化时显示行列号\u0026#34;\u0026#34;\u0026#34; cursor = self.text_edit.textCursor() line = cursor.blockNumber() + 1 col = cursor.columnNumber() + 1 self.status_bar.showMessage(f\u0026#34;行: {line}, 列: {col}\u0026#34;, 2000) def selection_changed(self): \u0026#34;\u0026#34;\u0026#34;文本选中时显示选中信息\u0026#34;\u0026#34;\u0026#34; cursor = self.text_edit.textCursor() if cursor.hasSelection(): selected = cursor.selectedText() self.status_bar.showMessage(f\u0026#34;已选: {len(selected)} 字符\u0026#34;, 2000) def load_large_file(self): \u0026#34;\u0026#34;\u0026#34;大文件分页加载优化\u0026#34;\u0026#34;\u0026#34; path, _ = QFileDialog.getOpenFileName(self, \u0026#34;打开大文件\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;文本文件 (*.txt)\u0026#34;) if not path: return # 大文件优化：只加载最后100行 try: with open(path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) as f: lines = [] # 高效读取最后100行 for line in f: lines.append(line) if len(lines) \u0026gt; 100: lines.pop(0) self.text_edit.setPlainText(\u0026#39;\u0026#39;.join(lines)) self.status_bar.showMessage(f\u0026#34;已加载大文件最后100行: {path}\u0026#34;, 5000) except Exception as e: QMessageBox.critical(self, \u0026#34;文件错误\u0026#34;, f\u0026#34;读取文件失败:\\n{str(e)}\u0026#34;) def check_unsaved_changes(self): \u0026#34;\u0026#34;\u0026#34;检查未保存的更改\u0026#34;\u0026#34;\u0026#34; if self.text_edit.document().isModified(): reply = QMessageBox.question(self, \u0026#34;未保存更改\u0026#34;, \u0026#34;当前文档有未保存的更改。是否保存？\u0026#34;, QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel) if reply == QMessageBox.Save: self.save_file() return True elif reply == QMessageBox.Cancel: return False return True if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) editor = RichTextEditor() editor.show() sys.exit(app.exec_()) QDialog 该控件是常用的对话窗口，为QWidget的子类，例如询问用户是否需要保存文件，输入数据或显示一些信息，可以设置对话框的标题、大小、位置等属性，也可以添加各种控件，例如标签、按钮、文本框等，可以捕获对话框关闭事件和其他事件，可以返回一些数据或响应用户的操作。\n方法： exec_()：将对话框设置为模态并运行对话框的事件循环，直到对话框被关闭。此方法通常用于从对话框中获取一些数据或响应用户的操作。 show()：显示对话框，但不将其设置为模态。此方法通常用于显示一些信息或提供一些选项。 done(int result)：设置对话框的返回值，并关闭对话框。此方法通常在用户进行某些操作后调用，以便通知调用方对话框的结果。 accept()：设置对话框的返回值为QDialog.Accepted，并关闭对话框。此方法通常在用户确认某些操作后调用，以便通知调用方对话框的结果。 ect()：设置对话框的返回值为QDialog.Rejected，并关闭对话框。此方法通常在用户取消某些操作后调用，以便通知调用方对话框的结果。 setButtonLayout(list)：设置对话框底部的按钮布局。参数list应该是一个QDialogButtonBox中定义的一组按钮类型，例如QDialogButtonBox.Ok | QDialogButtonBox.Cancel open()：将对话框设置为模态并运行对话框的事件循环，直到对话框被关闭。此方法与exec_()方法类似，但可以方便地打开多个对话框 除了上述方法外，QDialog还提供了一些其他方法，例如resize()、move()、close()、setVisible()等，这些方法与QWidget类似，用于设置对话框的大小、位置、可见性等\n属性： windowTitle：对话框的标题 windowIcon：对话框的图标 sizeGripEnabled：是否显示调整大小的手柄，默认为False layout：对话框的布局管理器，用于控制对话框内部控件的位置和大小 modal：是否将对话框设置为模态，即禁止用户与其他窗口交互，直到对话框被关闭，默认为True。 result：对话框的返回值，通常用于表示用户的操作或输入。如果对话框是通过exec_()方法调用的，则返回值是对话框的退出码（通常是QDialog.Accepted或QDialog.Rejected）；如果对话框是通过show()方法调用的，则返回值始终是None sizeHint：对话框的推荐大小。 acceptMode：对话框的接受模式，可以是QFileDialog.AcceptOpen（打开文件）、QFileDialog.AcceptSave（保存文件）或QFileDialog.AcceptSave（选择文件夹） rejectAction：当用户按下Esc键或者点击“取消”按钮时，对话框执行的操作。默认情况下，对话框将执行reject()方法并关闭 信号： finished(int result)：当对话框关闭并且返回值已经设置时发出。参数result表示对话框的返回值 accepted()：当用户确认某些操作并调用accept()方法时发出 rejected()：当用户取消某些操作并调用reject()方法时发出 resizeEvent(event)：当对话框的大小改变时发出。可以重写此方法来执行一些特定的操作 几种类型 普通对话框(QDialog)：最基本的对话框类型，用于显示消息、获取输入、提供选项等。它可以通过设置各种属性和使用布局管理器来控制对话框的大小、位置和内容 文件对话框(QFileDialog)：用于选择文件或文件夹的对话框。可以使用QFileDialog的静态方法创建各种类型的文件对话框，例如打开文件对话框、保存文件对话框、选择文件夹对话框等。 字体对话框(QFontDialog)：用于选择字体和字号的对话框。可以使用QFontDialog的静态方法创建字体对话框。 颜色对话框(QColorDialog)：用于选择颜色的对话框。可以使用QColorDialog的静态方法创建颜色对话框。 输入对话框(QInputDialog)：用于获取用户输入的对话框。可以使用QInputDialog的静态方法创建各种类型的输入对话框，例如文本输入对话框、整数输入对话框、浮点数输入对话框等。 消息框(QMessageBox)：用于显示消息和提供选项的对话框。可以使用QMessageBox的静态方法创建各种类型的消息框，例如信息框、警告框、错误框、询问框等. 鼠标指针对话框(QCursor)：用于显示不同类型的鼠标指针。可以使用QCursor的静态方法创建各种类型的鼠标指针对话框，例如箭头、十字形、等待指针等。 综合案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 import sys import os from PyQt5.QtWidgets import (QApplication, QDialog, QVBoxLayout, QHBoxLayout, QTextEdit, QPushButton, QMenuBar, QMenu, QAction, QFileDialog, QFontDialog, QInputDialog, QMessageBox) from PyQt5.QtGui import QTextCursor, QCursor from PyQt5.QtCore import Qt class TextEditor(QDialog): def __init__(self): super().__init__() self.current_file = None self.init_ui() def init_ui(self): # 设置窗口属性 self.setWindowTitle(\u0026#39;简易文本编辑器 - PyQt5对话框示例\u0026#39;) self.setGeometry(100, 100, 800, 600) # 创建主布局 main_layout = QVBoxLayout() # 创建菜单栏 menubar = QMenuBar() file_menu = QMenu(\u0026#39;文件\u0026#39;, self) edit_menu = QMenu(\u0026#39;编辑\u0026#39;, self) format_menu = QMenu(\u0026#39;格式\u0026#39;, self) help_menu = QMenu(\u0026#39;帮助\u0026#39;, self) # 添加文件菜单动作 new_action = QAction(\u0026#39;新建\u0026#39;, self) new_action.triggered.connect(self.new_file) open_action = QAction(\u0026#39;打开\u0026#39;, self) open_action.triggered.connect(self.open_file) save_action = QAction(\u0026#39;保存\u0026#39;, self) save_action.triggered.connect(self.save_file) save_as_action = QAction(\u0026#39;另存为\u0026#39;, self) save_as_action.triggered.connect(self.save_as_file) exit_action = QAction(\u0026#39;退出\u0026#39;, self) exit_action.triggered.connect(self.close) file_menu.addAction(new_action) file_menu.addAction(open_action) file_menu.addAction(save_action) file_menu.addAction(save_as_action) file_menu.addSeparator() file_menu.addAction(exit_action) # 添加编辑菜单动作 find_action = QAction(\u0026#39;查找\u0026#39;, self) find_action.triggered.connect(self.find_text) replace_action = QAction(\u0026#39;替换\u0026#39;, self) replace_action.triggered.connect(self.replace_text) edit_menu.addAction(find_action) edit_menu.addAction(replace_action) # 添加格式菜单动作 font_action = QAction(\u0026#39;字体\u0026#39;, self) font_action.triggered.connect(self.change_font) format_menu.addAction(font_action) # 添加帮助菜单动作 about_action = QAction(\u0026#39;关于\u0026#39;, self) about_action.triggered.connect(self.show_about) help_menu.addAction(about_action) # 将菜单添加到菜单栏 menubar.addMenu(file_menu) menubar.addMenu(edit_menu) menubar.addMenu(format_menu) menubar.addMenu(help_menu) # 创建文本编辑区域 self.text_edit = QTextEdit() # 创建底部按钮 button_layout = QHBoxLayout() clear_btn = QPushButton(\u0026#39;清空内容\u0026#39;) clear_btn.clicked.connect(self.clear_text) status_btn = QPushButton(\u0026#39;统计字数\u0026#39;) status_btn.clicked.connect(self.count_words) button_layout.addWidget(clear_btn) button_layout.addWidget(status_btn) button_layout.addStretch() # 将组件添加到主布局 main_layout.setMenuBar(menubar) main_layout.addWidget(self.text_edit) main_layout.addLayout(button_layout) self.setLayout(main_layout) def new_file(self): # 使用消息对话框确认是否保存当前文件 [7](@ref) if self.text_edit.document().isModified(): reply = QMessageBox.question(self, \u0026#39;确认\u0026#39;, \u0026#39;当前文档已修改，是否保存？\u0026#39;, QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel) if reply == QMessageBox.Save: self.save_file() elif reply == QMessageBox.Cancel: return self.text_edit.clear() self.current_file = None self.setWindowTitle(\u0026#39;新建文件 - 简易文本编辑器\u0026#39;) def open_file(self): # 使用文件对话框选择文件 [1](@ref) file_path, _ = QFileDialog.getOpenFileName(self, \u0026#39;打开文件\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;文本文件 (*.txt);;所有文件 (*)\u0026#39;) if file_path: try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: self.text_edit.setText(f.read()) self.current_file = file_path self.setWindowTitle(f\u0026#39;{os.path.basename(file_path)} - 简易文本编辑器\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, f\u0026#39;无法打开文件: {str(e)}\u0026#39;) def save_file(self): if self.current_file: try: with open(self.current_file, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(self.text_edit.toPlainText()) self.text_edit.document().setModified(False) QMessageBox.information(self, \u0026#39;成功\u0026#39;, \u0026#39;文件已保存！\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, f\u0026#39;无法保存文件: {str(e)}\u0026#39;) else: self.save_as_file() def save_as_file(self): # 使用文件对话框选择保存路径 [1](@ref) file_path, _ = QFileDialog.getSaveFileName(self, \u0026#39;另存为\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;文本文件 (*.txt);;所有文件 (*)\u0026#39;) if file_path: try: with open(file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(self.text_edit.toPlainText()) self.current_file = file_path self.setWindowTitle(f\u0026#39;{os.path.basename(file_path)} - 简易文本编辑器\u0026#39;) self.text_edit.document().setModified(False) QMessageBox.information(self, \u0026#39;成功\u0026#39;, \u0026#39;文件已保存！\u0026#39;) except Exception as e: QMessageBox.critical(self, \u0026#39;错误\u0026#39;, f\u0026#39;无法保存文件: {str(e)}\u0026#39;) def find_text(self): # 使用输入对话框获取查找内容 [2](@ref) text, ok = QInputDialog.getText(self, \u0026#39;查找\u0026#39;, \u0026#39;输入要查找的内容:\u0026#39;) if ok and text: # 使用QCursor改变光标状态 QApplication.setOverrideCursor(QCursor(Qt.WaitCursor)) content = self.text_edit.toPlainText() if text in content: # 定位到找到的文本 cursor = self.text_edit.textCursor() cursor.movePosition(QTextCursor.Start) self.text_edit.setTextCursor(cursor) # 高亮所有匹配项 self.text_edit.moveCursor(QTextCursor.Start) format = self.text_edit.textCursor().charFormat() format.setBackground(Qt.yellow) while self.text_edit.find(text): self.text_edit.textCursor().setCharFormat(format) QMessageBox.information(self, \u0026#39;查找\u0026#39;, f\u0026#39;找到 \u0026#34;{text}\u0026#34;！\u0026#39;) else: QMessageBox.information(self, \u0026#39;查找\u0026#39;, f\u0026#39;未找到 \u0026#34;{text}\u0026#34;\u0026#39;) QApplication.restoreOverrideCursor() def replace_text(self): # 使用输入对话框获取替换内容 [2](@ref) find_text, ok1 = QInputDialog.getText(self, \u0026#39;替换\u0026#39;, \u0026#39;输入要查找的内容:\u0026#39;) if ok1 and find_text: replace_text, ok2 = QInputDialog.getText(self, \u0026#39;替换\u0026#39;, \u0026#39;输入替换内容:\u0026#39;) if ok2: content = self.text_edit.toPlainText() if find_text in content: new_content = content.replace(find_text, replace_text) self.text_edit.setPlainText(new_content) QMessageBox.information(self, \u0026#39;替换\u0026#39;, \u0026#39;替换完成！\u0026#39;) else: QMessageBox.information(self, \u0026#39;替换\u0026#39;, f\u0026#39;未找到 \u0026#34;{find_text}\u0026#34;\u0026#39;) def change_font(self): # 使用字体对话框选择字体 [8](@ref) current_font = self.text_edit.currentFont() font, ok = QFontDialog.getFont(current_font, self, \u0026#39;选择字体\u0026#39;) if ok: self.text_edit.setCurrentFont(font) def clear_text(self): # 使用消息对话框确认清空操作 [7](@ref) reply = QMessageBox.question(self, \u0026#39;确认\u0026#39;, \u0026#39;确定要清空所有内容吗？\u0026#39;, QMessageBox.Yes | QMessageBox.No) if reply == QMessageBox.Yes: self.text_edit.clear() def count_words(self): text = self.text_edit.toPlainText() char_count = len(text) word_count = len(text.split()) line_count = text.count(\u0026#39;\\n\u0026#39;) + 1 if text else 0 # 使用消息对话框显示统计结果 [7](@ref) QMessageBox.information(self, \u0026#39;统计信息\u0026#39;, f\u0026#39;字符数: {char_count}\\n单词数: {word_count}\\n行数: {line_count}\u0026#39;) def show_about(self): # 使用消息对话框显示关于信息 [7](@ref) QMessageBox.about(self, \u0026#39;关于\u0026#39;, \u0026#39;简易文本编辑器\\n\\n\u0026#39; \u0026#39;演示PyQt5各种对话框的使用:\\n\u0026#39; \u0026#39;- QFileDialog: 文件打开和保存\\n\u0026#39; \u0026#39;- QFontDialog: 字体选择\\n\u0026#39; \u0026#39;- QInputDialog: 文本输入\\n\u0026#39; \u0026#39;- QMessageBox: 消息提示\\n\u0026#39; \u0026#39;- QCursor: 光标控制\u0026#39;) def closeEvent(self, event): # 重写关闭事件，确认是否保存 [7](@ref) if self.text_edit.document().isModified(): reply = QMessageBox.question(self, \u0026#39;确认退出\u0026#39;, \u0026#39;文档已修改，是否保存？\u0026#39;, QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel) if reply == QMessageBox.Save: self.save_file() event.accept() elif reply == QMessageBox.Discard: event.accept() else: event.ignore() else: event.accept() if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) editor = TextEditor() editor.show() sys.exit(app.exec_()) 容器 常见的PyQt容器有：\nQMainWindow：主窗口容器，通常包含菜单栏、工具栏、状态栏等 QWidget：基本的用户界面元素容器，可以作为其他容器的子容器 QGroupBox：分组框容器，可以将相关的组件放到一个分组框中，使它们更易于组织和查看 QTabWidget：选项卡容器，可以在多个选项卡中放置不同的组件，让用户轻松地在它们之间切换 QStackedWidget：堆栈容器，可以在同一位置上堆叠多个组件，只显示其中的一个，让用户可以轻松地在它们之间切换 QScrollArea：滚动区域容器，当容器中的组件太大，无法在当前视图中完全显示时，可以使用滚动区域容器 QSplitter：拆分器容器，可以将容器水平或垂直拆分为两个或更多子容器，让用户可以自由地调整它们的大小 QToolBar：工具栏容器，可以在主窗口或其他容器中放置多个工具栏，让用户可以快速访问常用功能 QGroupBox使用示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 import sys from PyQt5.QtWidgets import (QApplication, QDialog, QVBoxLayout, QHBoxLayout, QGroupBox, QRadioButton, QCheckBox, QPushButton, QLineEdit, QLabel, QComboBox) class GroupBoxExample(QDialog): def __init__(self): super().__init__() self.setWindowTitle(\u0026#39;QGroupBox 示例\u0026#39;) self.setGeometry(300, 300, 400, 300) self.init_ui() def init_ui(self): main_layout = QVBoxLayout() # 创建第一个分组框 - 单选按钮组 radio_group = QGroupBox(\u0026#34;用户类型\u0026#34;) radio_layout = QVBoxLayout() self.student_radio = QRadioButton(\u0026#34;学生\u0026#34;) self.teacher_radio = QRadioButton(\u0026#34;教师\u0026#34;) self.admin_radio = QRadioButton(\u0026#34;管理员\u0026#34;) self.student_radio.setChecked(True) radio_layout.addWidget(self.student_radio) radio_layout.addWidget(self.teacher_radio) radio_layout.addWidget(self.admin_radio) radio_group.setLayout(radio_layout) # 创建第二个分组框 - 复选框组 checkbox_group = QGroupBox(\u0026#34;兴趣爱好\u0026#34;) checkbox_layout = QVBoxLayout() self.reading_check = QCheckBox(\u0026#34;阅读\u0026#34;) self.sports_check = QCheckBox(\u0026#34;运动\u0026#34;) self.music_check = QCheckBox(\u0026#34;音乐\u0026#34;) self.travel_check = QCheckBox(\u0026#34;旅行\u0026#34;) checkbox_layout.addWidget(self.reading_check) checkbox_layout.addWidget(self.sports_check) checkbox_layout.addWidget(self.music_check) checkbox_layout.addWidget(self.travel_check) checkbox_group.setLayout(checkbox_layout) # 创建第三个分组框 - 表单输入 form_group = QGroupBox(\u0026#34;个人信息\u0026#34;) form_layout = QVBoxLayout() name_layout = QHBoxLayout() name_layout.addWidget(QLabel(\u0026#34;姓名:\u0026#34;)) self.name_input = QLineEdit() name_layout.addWidget(self.name_input) form_layout.addLayout(name_layout) age_layout = QHBoxLayout() age_layout.addWidget(QLabel(\u0026#34;年龄:\u0026#34;)) self.age_combo = QComboBox() self.age_combo.addItems([str(i) for i in range(18, 66)]) age_layout.addWidget(self.age_combo) form_layout.addLayout(age_layout) form_group.setLayout(form_layout) # 提交按钮 submit_btn = QPushButton(\u0026#34;提交信息\u0026#34;) submit_btn.clicked.connect(self.show_info) # 添加到主布局 main_layout.addWidget(radio_group) main_layout.addWidget(checkbox_group) main_layout.addWidget(form_group) main_layout.addWidget(submit_btn) self.setLayout(main_layout) def show_info(self): # 获取用户类型 user_type = \u0026#34;学生\u0026#34; if self.student_radio.isChecked() else \\ \u0026#34;教师\u0026#34; if self.teacher_radio.isChecked() else \u0026#34;管理员\u0026#34; # 获取兴趣爱好 hobbies = [] if self.reading_check.isChecked(): hobbies.append(\u0026#34;阅读\u0026#34;) if self.sports_check.isChecked(): hobbies.append(\u0026#34;运动\u0026#34;) if self.music_check.isChecked(): hobbies.append(\u0026#34;音乐\u0026#34;) if self.travel_check.isChecked(): hobbies.append(\u0026#34;旅行\u0026#34;) # 获取个人信息 name = self.name_input.text() or \u0026#34;未填写\u0026#34; age = self.age_combo.currentText() # 显示结果 print(f\u0026#34;用户类型: {user_type}\u0026#34;) print(f\u0026#34;姓名: {name}, 年龄: {age}\u0026#34;) print(f\u0026#34;兴趣爱好: {\u0026#39;, \u0026#39;.join(hobbies) if hobbies else \u0026#39;无\u0026#39;}\u0026#34;) print(\u0026#34;-\u0026#34; * 30) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) window = GroupBoxExample() window.show() sys.exit(app.exec_()) QTabWidget使用示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 import sys from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, QLabel, QPushButton, QLineEdit, QListWidget, QTextEdit, QHBoxLayout) class TabWidgetExample(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#39;QTabWidget 示例\u0026#39;) self.setGeometry(100, 100, 600, 400) self.init_ui() def init_ui(self): # 创建主窗口的中心部件 central_widget = QWidget() self.setCentralWidget(central_widget) # 创建主布局 main_layout = QVBoxLayout(central_widget) # 创建标签页部件 self.tab_widget = QTabWidget() # 创建三个标签页 self.create_tab1() self.create_tab2() self.create_tab3() # 将标签页添加到主布局 main_layout.addWidget(self.tab_widget) # 添加状态标签 self.status_label = QLabel(\u0026#34;当前标签: 信息页\u0026#34;) main_layout.addWidget(self.status_label) # 连接标签切换信号 self.tab_widget.currentChanged.connect(self.tab_changed) def create_tab1(self): \u0026#34;\u0026#34;\u0026#34;创建第一个标签页 - 信息页\u0026#34;\u0026#34;\u0026#34; tab1 = QWidget() layout = QVBoxLayout(tab1) # 添加一些控件 layout.addWidget(QLabel(\u0026#34;欢迎使用标签页示例程序\u0026#34;)) layout.addWidget(QLabel(\u0026#34;这是第一个标签页\u0026#34;)) # 添加输入框 self.name_input = QLineEdit() self.name_input.setPlaceholderText(\u0026#34;请输入您的姓名\u0026#34;) layout.addWidget(self.name_input) # 添加按钮 greet_btn = QPushButton(\u0026#34;打招呼\u0026#34;) greet_btn.clicked.connect(self.greet_user) layout.addWidget(greet_btn) # 添加结果标签 self.greet_label = QLabel(\u0026#34;\u0026#34;) layout.addWidget(self.greet_label) layout.addStretch() self.tab_widget.addTab(tab1, \u0026#34;信息页\u0026#34;) def create_tab2(self): \u0026#34;\u0026#34;\u0026#34;创建第二个标签页 - 列表页\u0026#34;\u0026#34;\u0026#34; tab2 = QWidget() layout = QVBoxLayout(tab2) # 添加列表控件 layout.addWidget(QLabel(\u0026#34;项目列表:\u0026#34;)) self.list_widget = QListWidget() self.list_widget.addItems([\u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;]) layout.addWidget(self.list_widget) # 添加按钮布局 btn_layout = QHBoxLayout() add_btn = QPushButton(\u0026#34;添加项目\u0026#34;) add_btn.clicked.connect(self.add_item) btn_layout.addWidget(add_btn) remove_btn = QPushButton(\u0026#34;删除项目\u0026#34;) remove_btn.clicked.connect(self.remove_item) btn_layout.addWidget(remove_btn) layout.addLayout(btn_layout) layout.addStretch() self.tab_widget.addTab(tab2, \u0026#34;列表页\u0026#34;) def create_tab3(self): \u0026#34;\u0026#34;\u0026#34;创建第三个标签页 - 编辑页\u0026#34;\u0026#34;\u0026#34; tab3 = QWidget() layout = QVBoxLayout(tab3) # 添加文本编辑控件 layout.addWidget(QLabel(\u0026#34;编辑区域:\u0026#34;)) self.text_edit = QTextEdit() self.text_edit.setPlaceholderText(\u0026#34;在此输入文本...\u0026#34;) layout.addWidget(self.text_edit) # 添加按钮 clear_btn = QPushButton(\u0026#34;清空内容\u0026#34;) clear_btn.clicked.connect(self.clear_text) layout.addWidget(clear_btn) layout.addStretch() self.tab_widget.addTab(tab3, \u0026#34;编辑页\u0026#34;) def greet_user(self): \u0026#34;\u0026#34;\u0026#34;打招呼按钮的槽函数\u0026#34;\u0026#34;\u0026#34; name = self.name_input.text().strip() if name: self.greet_label.setText(f\u0026#34;你好, {name}!\u0026#34;) else: self.greet_label.setText(\u0026#34;请输入您的姓名\u0026#34;) def add_item(self): \u0026#34;\u0026#34;\u0026#34;添加项目按钮的槽函数\u0026#34;\u0026#34;\u0026#34; self.list_widget.addItem(f\u0026#34;项目{self.list_widget.count() + 1}\u0026#34;) def remove_item(self): \u0026#34;\u0026#34;\u0026#34;删除项目按钮的槽函数\u0026#34;\u0026#34;\u0026#34; current_row = self.list_widget.currentRow() if current_row \u0026gt;= 0: self.list_widget.takeItem(current_row) def clear_text(self): \u0026#34;\u0026#34;\u0026#34;清空文本按钮的槽函数\u0026#34;\u0026#34;\u0026#34; self.text_edit.clear() def tab_changed(self, index): \u0026#34;\u0026#34;\u0026#34;标签切换时的槽函数\u0026#34;\u0026#34;\u0026#34; tab_name = self.tab_widget.tabText(index) self.status_label.setText(f\u0026#34;当前标签: {tab_name}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) window = TabWidgetExample() window.show() sys.exit(app.exec_()) QStackedWidget使用示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 import sys from PyQt5.QtWidgets import (QApplication, QMainWindow, QStackedWidget, QWidget, QVBoxLayout, QLabel, QPushButton, QLineEdit, QListWidget, QTextEdit, QHBoxLayout, QGroupBox) class StackedWidgetExample(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#39;QStackedWidget 示例\u0026#39;) self.setGeometry(100, 100, 600, 400) self.init_ui() def init_ui(self): # 创建主窗口的中心部件 central_widget = QWidget() self.setCentralWidget(central_widget) # 创建主布局 main_layout = QVBoxLayout(central_widget) # 创建堆叠窗口部件 self.stacked_widget = QStackedWidget() # 创建三个页面 self.create_page1() self.create_page2() self.create_page3() # 将堆叠窗口添加到主布局 main_layout.addWidget(self.stacked_widget) # 创建导航按钮 nav_layout = QHBoxLayout() prev_btn = QPushButton(\u0026#34;上一页\u0026#34;) prev_btn.clicked.connect(self.prev_page) nav_layout.addWidget(prev_btn) next_btn = QPushButton(\u0026#34;下一页\u0026#34;) next_btn.clicked.connect(self.next_page) nav_layout.addWidget(next_btn) main_layout.addLayout(nav_layout) # 添加状态标签 self.status_label = QLabel(\u0026#34;当前页面: 1/3\u0026#34;) main_layout.addWidget(self.status_label) def create_page1(self): \u0026#34;\u0026#34;\u0026#34;创建第一个页面 - 信息页\u0026#34;\u0026#34;\u0026#34; page1 = QWidget() layout = QVBoxLayout(page1) # 添加分组框 group_box = QGroupBox(\u0026#34;用户信息\u0026#34;) group_layout = QVBoxLayout() # 添加输入框 self.name_input = QLineEdit() self.name_input.setPlaceholderText(\u0026#34;请输入您的姓名\u0026#34;) group_layout.addWidget(self.name_input) # 添加按钮 greet_btn = QPushButton(\u0026#34;打招呼\u0026#34;) greet_btn.clicked.connect(self.greet_user) group_layout.addWidget(greet_btn) # 添加结果标签 self.greet_label = QLabel(\u0026#34;\u0026#34;) group_layout.addWidget(self.greet_label) group_box.setLayout(group_layout) layout.addWidget(group_box) layout.addStretch() self.stacked_widget.addWidget(page1) def create_page2(self): \u0026#34;\u0026#34;\u0026#34;创建第二个页面 - 列表页\u0026#34;\u0026#34;\u0026#34; page2 = QWidget() layout = QVBoxLayout(page2) # 添加分组框 group_box = QGroupBox(\u0026#34;项目列表\u0026#34;) group_layout = QVBoxLayout() # 添加列表控件 self.list_widget = QListWidget() self.list_widget.addItems([\u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;]) group_layout.addWidget(self.list_widget) # 添加按钮布局 btn_layout = QHBoxLayout() add_btn = QPushButton(\u0026#34;添加项目\u0026#34;) add_btn.clicked.connect(self.add_item) btn_layout.addWidget(add_btn) remove_btn = QPushButton(\u0026#34;删除项目\u0026#34;) remove_btn.clicked.connect(self.remove_item) btn_layout.addWidget(remove_btn) group_layout.addLayout(btn_layout) group_box.setLayout(group_layout) layout.addWidget(group_box) layout.addStretch() self.stacked_widget.addWidget(page2) def create_page3(self): \u0026#34;\u0026#34;\u0026#34;创建第三个页面 - 编辑页\u0026#34;\u0026#34;\u0026#34; page3 = QWidget() layout = QVBoxLayout(page3) # 添加分组框 group_box = QGroupBox(\u0026#34;文本编辑\u0026#34;) group_layout = QVBoxLayout() # 添加文本编辑控件 self.text_edit = QTextEdit() self.text_edit.setPlaceholderText(\u0026#34;在此输入文本...\u0026#34;) group_layout.addWidget(self.text_edit) # 添加按钮 clear_btn = QPushButton(\u0026#34;清空内容\u0026#34;) clear_btn.clicked.connect(self.clear_text) group_layout.addWidget(clear_btn) group_box.setLayout(group_layout) layout.addWidget(group_box) layout.addStretch() self.stacked_widget.addWidget(page3) def greet_user(self): \u0026#34;\u0026#34;\u0026#34;打招呼按钮的槽函数\u0026#34;\u0026#34;\u0026#34; name = self.name_input.text().strip() if name: self.greet_label.setText(f\u0026#34;你好, {name}!\u0026#34;) else: self.greet_label.setText(\u0026#34;请输入您的姓名\u0026#34;) def add_item(self): \u0026#34;\u0026#34;\u0026#34;添加项目按钮的槽函数\u0026#34;\u0026#34;\u0026#34; self.list_widget.addItem(f\u0026#34;项目{self.list_widget.count() + 1}\u0026#34;) def remove_item(self): \u0026#34;\u0026#34;\u0026#34;删除项目按钮的槽函数\u0026#34;\u0026#34;\u0026#34; current_row = self.list_widget.currentRow() if current_row \u0026gt;= 0: self.list_widget.takeItem(current_row) def clear_text(self): \u0026#34;\u0026#34;\u0026#34;清空文本按钮的槽函数\u0026#34;\u0026#34;\u0026#34; self.text_edit.clear() def prev_page(self): \u0026#34;\u0026#34;\u0026#34;上一页按钮的槽函数\u0026#34;\u0026#34;\u0026#34; current_index = self.stacked_widget.currentIndex() if current_index \u0026gt; 0: self.stacked_widget.setCurrentIndex(current_index - 1) self.update_status() def next_page(self): \u0026#34;\u0026#34;\u0026#34;下一页按钮的槽函数\u0026#34;\u0026#34;\u0026#34; current_index = self.stacked_widget.currentIndex() if current_index \u0026lt; self.stacked_widget.count() - 1: self.stacked_widget.setCurrentIndex(current_index + 1) self.update_status() def update_status(self): \u0026#34;\u0026#34;\u0026#34;更新状态标签\u0026#34;\u0026#34;\u0026#34; current_index = self.stacked_widget.currentIndex() + 1 total_pages = self.stacked_widget.count() self.status_label.setText(f\u0026#34;当前页面: {current_index}/{total_pages}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) window = StackedWidgetExample() window.show() sys.exit(app.exec_()) QSplitters使用示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import sys from PyQt5.QtWidgets import (QApplication, QMainWindow, QSplitter, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QListWidget, QTreeWidget, QTreeWidgetItem) class SplitterExample(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#39;QSplitter 示例\u0026#39;) self.setGeometry(100, 100, 800, 600) self.init_ui() def init_ui(self): # 创建主窗口的中心部件 central_widget = QWidget() self.setCentralWidget(central_widget) # 创建主布局 main_layout = QVBoxLayout(central_widget) # 创建水平分割器 horizontal_splitter = QSplitter() horizontal_splitter.setOrientation(0) # 0 表示水平方向 # 创建左侧区域 - 文本编辑区 left_widget = QWidget() left_layout = QVBoxLayout(left_widget) left_layout.addWidget(QLabel(\u0026#34;文本编辑区\u0026#34;)) self.text_edit = QTextEdit() self.text_edit.setPlaceholderText(\u0026#34;在此输入文本...\u0026#34;) left_layout.addWidget(self.text_edit) horizontal_splitter.addWidget(left_widget) # 创建垂直分割器（嵌套在水平分割器中） vertical_splitter = QSplitter() vertical_splitter.setOrientation(1) # 1 表示垂直方向 # 创建右上区域 - 列表区 top_right_widget = QWidget() top_right_layout = QVBoxLayout(top_right_widget) top_right_layout.addWidget(QLabel(\u0026#34;项目列表\u0026#34;)) self.list_widget = QListWidget() self.list_widget.addItems([\u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;]) top_right_layout.addWidget(self.list_widget) vertical_splitter.addWidget(top_right_widget) # 创建右下区域 - 树形结构区 bottom_right_widget = QWidget() bottom_right_layout = QVBoxLayout(bottom_right_widget) bottom_right_layout.addWidget(QLabel(\u0026#34;树形结构\u0026#34;)) self.tree_widget = QTreeWidget() self.tree_widget.setHeaderLabels([\u0026#34;名称\u0026#34;, \u0026#34;类型\u0026#34;]) # 添加树形结构数据 root = QTreeWidgetItem(self.tree_widget) root.setText(0, \u0026#34;根节点\u0026#34;) child1 = QTreeWidgetItem(root) child1.setText(0, \u0026#34;子节点1\u0026#34;) child1.setText(1, \u0026#34;文件夹\u0026#34;) child2 = QTreeWidgetItem(root) child2.setText(0, \u0026#34;子节点2\u0026#34;) child2.setText(1, \u0026#34;文件\u0026#34;) self.tree_widget.expandAll() bottom_right_layout.addWidget(self.tree_widget) vertical_splitter.addWidget(bottom_right_widget) # 将垂直分割器添加到水平分割器 horizontal_splitter.addWidget(vertical_splitter) # 设置初始比例 horizontal_splitter.setSizes([300, 500]) vertical_splitter.setSizes([200, 300]) # 添加分割器到主布局 main_layout.addWidget(horizontal_splitter) # 添加状态标签 self.status_label = QLabel(\u0026#34;拖动分隔条调整各区域大小\u0026#34;) main_layout.addWidget(self.status_label) # 连接信号 horizontal_splitter.splitterMoved.connect(self.update_status) vertical_splitter.splitterMoved.connect(self.update_status) def update_status(self, pos, index): \u0026#34;\u0026#34;\u0026#34;更新状态标签\u0026#34;\u0026#34;\u0026#34; self.status_label.setText(f\u0026#34;当前分隔条位置: {pos}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) window = SplitterExample() window.show() sys.exit(app.exec_()) 布局管理器 QFormLayout 用于构建图形用户界面（GUI）中表单的布局管理器。它可以在表单中自动地安排各种控件（例如文本框、复选框、下拉框等）的位置和大小，以便它们以最优化的方式显示在表单上。\n简化表单的设计和排版工作，以及提高表单的可读性和易用性 根据表单中控件的类型和数量，自动地生成最佳的布局 提供了一些常用的功能，例如表单边距、控件间距、对齐方式、自动换行等 QGridLayout 用于将控件以网格的形式排列在窗口中。每个单元格可以包含一个控件，且所有单元格大小相等。控件可以跨越多个行和列，这是通过指定控件的位置以及它在行和列中所占的单元格数量来实现的。重要特点：\n创建GridLayout对象：可以通过将QWidget作为参数传递给QGridLayout构造函数来创建一个GridLayout对象。然后可以使用addWidget()方法将控件添加到布局中 指定控件的位置：可以使用addWidget()方法的第二个和第三个参数来指定控件的位置。例如，addWidget(button, 0, 0)将button添加到第0行和第0列的单元格中 控件的大小和跨度：可以使用addWidget()方法的第四个和第五个参数来指定控件在行和列中所占的单元格数量。例如，addWidget(label, 0, 0, 1, 2)将label添加到第0行和第0列的单元格中，并让它跨越第0列和第1列的两个单元格 添加空白单元格：可以使用addSpacing()方法添加空白的单元格，从而调整控件之间的距离 对齐方式：可以使用setAlignment()方法设置控件在单元格中的对齐方式。可以指定水平和垂直方向的对齐方式，也可以将对齐方式设置为水平和垂直方向的组合 自动调整大小：可以使用setColumnStretch()和setRowStretch()方法来设置单元格的大小。可以使用addStretch()方法添加一个伸缩项，以便在窗口大小改变时自动调整大小 信号与槽以及关联控件 信号与槽的介绍 信号是用于在对象之间传递信息的一种机制。一个信号表示了一个事件或状态的变化，当这个事件或状态变化时，信号被发射（emit）。可以将信号连接到一个或多个槽函数中，当信号被发射时，连接的槽函数会被调用执行。槽函数则是用于接收和处理信号的函数。\n常用**connect()**方法来将信号连接到槽函数中，该方法的基本语法为：\n1 sender.signal.connect(receiver.slot) sender表示发送信号的对象，signal表示信号的名称，connect()方法将信号signal连接到receiver对象的槽函数slot中。槽函数可以是任何可调用的Python函数\n高级的信号与槽机制：\n使用自定义信号：可以定义自己的信号，并将其连接到槽函数中。自定义信号可以通过QObject类的signal()方法定义，并使用emit()方法发射信号 使用Lambda表达式：可以使用Lambda表达式作为槽函数，Lambda表达式可以简洁地表示一个函数 使用信号参数：PyQt5中的信号可以带有参数，参数可以在信号发射时被传递给槽函数 一个信号连接多个槽函数：可以将一个信号连接到多个槽函数中，所有的槽函数都会在信号被发射时被调用执行 QPushButton Qt中常用的按钮控件，可以用于在GUI中创建各种类型的按钮，如普通按钮、复选框按钮、单选框按钮等。\n其构造函数为：\n1 2 3 QPushButton(parent=None) #创建一个无标签的按钮 QPushButton(str, parent=None)\t#创建一个有标签的按钮 QPushButton(QIcon, str, parent=None)#创建一个既有图标又有标签的按钮 可以调用的方法有：\nsetText()方法设置按钮的文本标签 setIcon()方法设置按钮的图标 setEnabled()用于设置按钮是否可用 setFlat()用于设置按钮是否平面 setCheckable()用于设置按钮是否可选中等 还可以通过信号与槽机制来响应用户的点击事件。当用户单击按钮时，会发出clicked()信号，可以通过连接这个信号来执行特定的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QLabel, QHBoxLayout, QVBoxLayout, QWidget from PyQt5.QtGui import QIcon from PyQt5.QtCore import Qt class MyMainWindow(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle(\u0026#39;QPushButton Demo\u0026#39;) self.setGeometry(300, 300, 400, 300) # 创建一个QPushButton并设置文本标签和图标 btn = QPushButton(\u0026#39;Click me!\u0026#39;, self) btn.setIcon(QIcon(\u0026#39;icon.png\u0026#39;)) # 连接按钮的clicked信号到槽函数onBtnClicked btn.clicked.connect(self.onBtnClicked) # 创建一个QLabel用于显示按钮状态 self.label = QLabel(\u0026#39;Button not clicked\u0026#39;, self) # 创建水平布局和垂直布局，并将按钮和标签添加到布局中 hbox = QHBoxLayout() hbox.addStretch(1) hbox.addWidget(btn) hbox.addStretch(1) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) vbox.addStretch(1) vbox.addWidget(self.label, alignment=Qt.AlignCenter) # 创建一个QWidget，并将垂直布局添加到QWidget中 widget = QWidget() widget.setLayout(vbox) self.setCentralWidget(widget) def onBtnClicked(self): self.label.setText(\u0026#39;Button clicked\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) win = MyMainWindow() win.show() sys.exit(app.exec_()) QRadioButton 一个单选按钮控件，可以用于从多个互斥的选项中选择一个选项。与QCheckBox不同，QRadioButton只允许选择一个选项。\n基本属性和方法：\nsetText()设置按钮的文本 isChecked()检查按钮是否被选中 setChecked()设置按钮的选中状态 toggled()每当按钮的选中状态发生变化时，都会发出toggled()信号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QRadioButton class MyMainWindow(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle(\u0026#39;QRadioButton Demo\u0026#39;) self.setGeometry(300, 300, 400, 300) # 创建两个单选框按钮 rb1 = QRadioButton(\u0026#39;Option 1\u0026#39;, self) rb1.move(50, 50) rb1.setChecked(True) rb2 = QRadioButton(\u0026#39;Option 2\u0026#39;, self) rb2.move(50, 80) # 绑定toggled()信号 rb1.toggled.connect(self.onToggled) rb2.toggled.connect(self.onToggled) def onToggled(self, checked): sender = self.sender() if checked: print(sender.text() + \u0026#39; is checked\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) win = MyMainWindow() win.show() sys.exit(app.exec_()) QcheckBox 一个复选框控件，可以用于从多个选项中选择一个或多个选项。与QRadioButton不同，QCheckBox允许选择多个选项。\n基本属性和方法：\nsetText()：设置复选框的文本。 isChecked()：检查复选框是否被选中。 setChecked()：设置复选框的选中状态。 stateChanged()：每当复选框的选中状态发生变化时，都会发出stateChanged()信号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QCheckBox class MyMainWindow(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle(\u0026#39;QCheckBox Demo\u0026#39;) self.setGeometry(300, 300, 400, 300) # 创建两个复选框 cb1 = QCheckBox(\u0026#39;Option 1\u0026#39;, self) cb1.move(50, 50) cb2 = QCheckBox(\u0026#39;Option 2\u0026#39;, self) cb2.move(50, 80) # 绑定stateChanged()信号 cb1.stateChanged.connect(self.onStateChanged) cb2.stateChanged.connect(self.onStateChanged) def onStateChanged(self, state): sender = self.sender() if state == 2: print(sender.text() + \u0026#39; is checked\u0026#39;) else: print(sender.text() + \u0026#39; is unchecked\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) win = MyMainWindow() win.show() sys.exit(app.exec_()) QComboBox 下拉列表控件，允许用户从预定义的一组选项中选择一个或多个选项。它通常用于表示枚举类型的值或选择一组预定义的选项。\n基本属性和方法：\naddItem()：添加一个项到下拉列表中。 addItems()：添加多个项到下拉列表中。 setCurrentIndex()：设置当前选中的项的索引。 currentText()：返回当前选中的项的文本。 currentIndexChanged()：每当当前选中的项发生变化时，都会发出currentIndexChanged()信号。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 import sys from PyQt5.QtWidgets import (QApplication, QMainWindow, QComboBox, QPushButton, QVBoxLayout, QWidget, QLabel) class ComboBoxDemo(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#39;QComboBox 演示\u0026#39;) self.setGeometry(300, 300, 400, 300) self.initUI() def initUI(self): # 创建中心部件和布局 central_widget = QWidget() self.setCentralWidget(central_widget) layout = QVBoxLayout(central_widget) # 创建标签显示当前选择 self.status_label = QLabel(\u0026#34;当前选择: 无\u0026#34;) layout.addWidget(self.status_label) # 创建下拉列表并添加选项 self.combo_box = QComboBox() self.combo_box.addItem(\u0026#39;选项 1\u0026#39;) self.combo_box.addItem(\u0026#39;选项 2\u0026#39;) self.combo_box.addItem(\u0026#39;选项 3\u0026#39;) self.combo_box.addItem(\u0026#39;选项 4\u0026#39;) self.combo_box.addItem(\u0026#39;选项 5\u0026#39;) # 绑定信号 self.combo_box.currentIndexChanged.connect(self.on_index_changed) layout.addWidget(self.combo_box) # 创建按钮用于设置当前索引 self.create_set_index_buttons(layout) # 添加随机选择按钮 random_btn = QPushButton(\u0026#34;随机选择\u0026#34;) random_btn.clicked.connect(self.set_random_index) layout.addWidget(random_btn) # 添加重置按钮 reset_btn = QPushButton(\u0026#34;重置选择\u0026#34;) reset_btn.clicked.connect(self.reset_selection) layout.addWidget(reset_btn) # 初始化状态 self.update_status() def create_set_index_buttons(self, layout): \u0026#34;\u0026#34;\u0026#34;创建设置索引的按钮\u0026#34;\u0026#34;\u0026#34; # 水平布局用于放置按钮 button_layout = QVBoxLayout() # 为每个选项创建设置按钮 for i in range(self.combo_box.count()): btn = QPushButton(f\u0026#34;设置为选项 {i + 1}\u0026#34;) # 使用lambda函数传递索引值 btn.clicked.connect(lambda checked, idx=i: self.set_current_index(idx)) button_layout.addWidget(btn) layout.addLayout(button_layout) def set_current_index(self, index): \u0026#34;\u0026#34;\u0026#34;设置当前选中的索引\u0026#34;\u0026#34;\u0026#34; self.combo_box.setCurrentIndex(index) def set_random_index(self): \u0026#34;\u0026#34;\u0026#34;随机选择一个索引\u0026#34;\u0026#34;\u0026#34; import random count = self.combo_box.count() if count \u0026gt; 0: random_index = random.randint(0, count - 1) self.combo_box.setCurrentIndex(random_index) def reset_selection(self): \u0026#34;\u0026#34;\u0026#34;重置选择（设置为无选择）\u0026#34;\u0026#34;\u0026#34; self.combo_box.setCurrentIndex(-1) def on_index_changed(self, index): \u0026#34;\u0026#34;\u0026#34;当下拉列表选择改变时调用\u0026#34;\u0026#34;\u0026#34; self.update_status() def update_status(self): \u0026#34;\u0026#34;\u0026#34;更新状态标签\u0026#34;\u0026#34;\u0026#34; index = self.combo_box.currentIndex() text = self.combo_box.currentText() if index == -1: self.status_label.setText(\u0026#34;当前选择: 无\u0026#34;) else: self.status_label.setText(f\u0026#34;当前选择: 选项 {index + 1} ({text})\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) win = ComboBoxDemo() win.show() sys.exit(app.exec_()) 独立组件 滑块控件 图形用户界面中常见的一种控件，也称为滑杆、拖动条、进度条等，用于调节数值类型的参数。用户通过拖动滑块的滑块块（Thumb）来改变滑块的值，滑块的范围和步长可以通过设置属性进行控制。在PyQt5中，QSlider是用于创建滑块控件的类。\n常用的属性和方法：\nvalue()：获取当前滑块的值。 setValue(value)：设置当前滑块的值。 minimum()：获取滑块的最小值。 setMinimum(value)：设置滑块的最小值。 maximum()：获取滑块的最大值。 setMaximum(value)：设置滑块的最大值。 singleStep()：获取滑块的步长。 setSingleStep(value)：设置滑块的步长。 sliderMoved.connect(slot)：将slot函数连接到滑块拖动事件。 valueChanged.connect(slot)：将slot函数连接到滑块值改变事件。 在使用QS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import sys from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QSlider, QHBoxLayout, QVBoxLayout, QPushButton from PyQt5.QtCore import Qt class SliderDemo(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): # 创建一个水平布局和垂直布局 hlayout = QHBoxLayout() vlayout = QVBoxLayout() # 创建一个标签和滑块控件，并添加到水平布局中 self.label = QLabel(\u0026#39;Value: 0\u0026#39;) self.slider = QSlider(Qt.Horizontal) self.slider.valueChanged[int].connect(self.onSliderValueChanged) hlayout.addWidget(self.label) hlayout.addWidget(self.slider) # 创建一个重置按钮，并添加到垂直布局中 reset_btn = QPushButton(\u0026#39;Reset\u0026#39;) reset_btn.clicked.connect(self.onResetBtnClicked) vlayout.addLayout(hlayout) vlayout.addWidget(reset_btn) # 设置窗口的布局 self.setLayout(vlayout) # 设置窗口的标题和大小 self.setWindowTitle(\u0026#39;Slider Demo\u0026#39;) self.resize(300, 200) def onSliderValueChanged(self, value): # 当滑块的值改变时更新标签的文本 self.label.setText(f\u0026#39;Value: {value}\u0026#39;) def onResetBtnClicked(self): # 重置滑块的值为0，并更新标签的文本 self.slider.setValue(0) self.label.setText(\u0026#39;Value: 0\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) demo = SliderDemo() demo.show() sys.exit(app.exec_()) 树控件 一种常见的用户界面控件，它可以用来展示层次化的数据结构，例如文件系统、目录结构、组织结构等等。树控件通常由多个节点（Node）组成，每个节点都可以包含多个子节点。在PyQt5中，树控件是通过QTreeWidget类来实现的。\n操作树控件方法：\n添加节点：可以通过QTreeWidget.addTopLevelItem()方法或QTreeWidgetItem.addChild()方法来添加节点。 删除节点：可以通过QTreeWidget.takeTopLevelItem()方法或QTreeWidgetItem.removeChild()方法来删除节点。 获取节点：可以通过QTreeWidget.topLevelItem()方法或QTreeWidgetItem.child()方法来获取节点。 设置节点属性：可以通过QTreeWidgetItem.setText()、QTreeWidgetItem.setIcon()等方法来设置节点的文本、图标等属性。 选择节点：可以通过QTreeWidget.currentItem()方法获取当前选中的节点，也可以通过QTreeWidgetItem.setSelected 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QTreeWidget, QTreeWidgetItem class OrganizationChart(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;组织结构图\u0026#34;) self.resize(500, 400) self.treeWidget = QTreeWidget() self.treeWidget.setHeaderLabels([\u0026#34;姓名\u0026#34;, \u0026#34;职位\u0026#34;, \u0026#34;部门\u0026#34;]) self.populateTreeWidget() self.setCentralWidget(self.treeWidget) def populateTreeWidget(self): # 创建根节点 root = QTreeWidgetItem(self.treeWidget, [\u0026#34;总经理\u0026#34;, \u0026#34;总经理\u0026#34;, \u0026#34;\u0026#34;]) # 创建部门节点1 department1 = QTreeWidgetItem(root, [\u0026#34;市场部\u0026#34;, \u0026#34;部门经理\u0026#34;, \u0026#34;\u0026#34;]) employee1 = QTreeWidgetItem(department1, [\u0026#34;张三\u0026#34;, \u0026#34;销售经理\u0026#34;, \u0026#34;市场部\u0026#34;]) employee2 = QTreeWidgetItem(department1, [\u0026#34;李四\u0026#34;, \u0026#34;市场专员\u0026#34;, \u0026#34;市场部\u0026#34;]) # 创建部门节点2 department2 = QTreeWidgetItem(root, [\u0026#34;技术部\u0026#34;, \u0026#34;部门经理\u0026#34;, \u0026#34;\u0026#34;]) employee3 = QTreeWidgetItem(department2, [\u0026#34;王五\u0026#34;, \u0026#34;技术总监\u0026#34;, \u0026#34;技术部\u0026#34;]) employee4 = QTreeWidgetItem(department2, [\u0026#34;赵六\u0026#34;, \u0026#34;开发工程师\u0026#34;, \u0026#34;技术部\u0026#34;]) # 展开根节点 self.treeWidget.expandItem(root) if __name__ == \u0026#34;__main__\u0026#34;: app = QApplication(sys.argv) organizationChart = OrganizationChart() organizationChart.show() sys.exit(app.exec_()) 停靠控件 一种常用的界面布局控件，它允许用户在主窗口中创建可停靠的面板或工具栏，以便对应用程序进行灵活的布局和组织。停靠控件提供了一种便捷的方式来管理和切换应用程序的功能模块，使用户可以根据自己的需求动态调整界面布局。在 PyQt 中，停靠控件由QDockWidget类实现。它可以与 QMainWindow 或 QMainWindows 的派生类一起使用，使得应用程序的主窗口可以容纳多个停靠控件，并支持拖动、停靠和浮动等操作。\n实现步骤：\n创建停靠控件对象：使用 QDockWidget 类创建一个停靠控件对象，并将需要承载的内容设置为其子部件。 设置停靠属性：可以设置停靠控件的标题、图标、位置等属性，以及允许的停靠区域和停靠方式。 将停靠控件添加到主窗口：使用 QMainWindow 或 QMainWindows 的派生类将停靠控件添加到主窗口中的合适位置，通常使用 addDockWidget() 方法来完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QDockWidget, QTextEdit, QAction, QFileDialog, QMessageBox, QVBoxLayout, QWidget, QLabel, QPushButton, QTreeWidget, QTreeWidgetItem class NotePad(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setWindowTitle(\u0026#34;NotePad\u0026#34;) self.setGeometry(100, 100, 800, 600) # 创建文本编辑区域 self.textEdit = QTextEdit() self.setCentralWidget(self.textEdit) # 创建停靠控件 dock = QDockWidget(\u0026#34;File Actions\u0026#34;, self) dock.setAllowedAreas(Qt.LeftDockWidgetArea) # 创建停靠控件中的内容，包括打开文件按钮和保存文件按钮 openButton = QPushButton(\u0026#34;Open File\u0026#34;) openButton.clicked.connect(self.openFile) saveButton = QPushButton(\u0026#34;Save File\u0026#34;) saveButton.clicked.connect(self.saveFile) layout = QVBoxLayout() layout.addWidget(openButton) layout.addWidget(saveButton) widget = QWidget() widget.setLayout(layout) dock.setWidget(widget) # 将停靠控件添加到主窗口的左侧停靠区域 self.addDockWidget(Qt.LeftDockWidgetArea, dock) # 创建菜单和动作 self.createActions() self.createMenus() # 创建侧边栏 self.createSidebar() self.show() def createActions(self): self.openAction = QAction(\u0026#34;Open File\u0026#34;, self) self.openAction.triggered.connect(self.openFile) self.saveAction = QAction(\u0026#34;Save File\u0026#34;, self) self.saveAction.triggered.connect(self.saveFile) def createMenus(self): self.fileMenu = self.menuBar().addMenu(\u0026#34;File\u0026#34;) self.fileMenu.addAction(self.openAction) self.fileMenu.addAction(self.saveAction) def createSidebar(self): # 创建侧边栏 sidebarDock = QDockWidget(\u0026#34;Notes\u0026#34;, self) sidebarDock.setAllowedAreas(Qt.LeftDockWidgetArea) # 创建树控件 treeWidget = QTreeWidget() treeWidget.setHeaderLabels([\u0026#34;Notes\u0026#34;]) # 添加示例笔记 root = QTreeWidgetItem(treeWidget) root.setText(0, \u0026#34;Notebook\u0026#34;) note1 = QTreeWidgetItem(root) note1.setText(0, \u0026#34;Note 1\u0026#34;) note2 = QTreeWidgetItem(root) note2.setText(0, \u0026#34;Note 2\u0026#34;) # 将树控件添加到侧边栏 sidebarDock.setWidget(treeWidget) self.addDockWidget(Qt.LeftDockWidgetArea, sidebarDock) def openFile(self): fileName, _ = QFileDialog.getOpenFileName(self, \u0026#34;Open File\u0026#34;) if fileName: try: with open(fileName, \u0026#39;r\u0026#39;) as file: content = file.read() self.textEdit.setPlainText(content) except Exception as e: QMessageBox.critical(self, \u0026#34;Error\u0026#34;, str(e)) def saveFile(self): fileName, _ = QFileDialog.getSaveFileName(self, \u0026#34;Save File\u0026#34;) if fileName: try: with open(fileName, \u0026#39;w\u0026#39;) as file: content = self.textEdit.toPlainText() file.write(content) QMessageBox.information(self, \u0026#34;Success\u0026#34;, \u0026#34;File saved successfully.\u0026#34;) except Exception as e: QMessageBox.critical(self, \u0026#34;Error\u0026#34;, str(e)) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) notepad = NotePad() sys.exit(app.exec_()) ","date":"2025-08-22T20:41:39+08:00","image":"https://Entars.github.io/p/pyqt5/1_hu_b950930e3bc458.jpeg","permalink":"https://Entars.github.io/p/pyqt5/","title":"PyQt5"},{"content":"获取Cookie ​\t起初在进入到岗位页面时，发现无需登录也能访问岗位列表，因此打算直接从网络中找到返回工作列表的请求，通过侧边栏搜索相关字段，定位请求位置:\n获取其中的请求URL和Cookie等参数，构造请求头并发起请求。在此过程中发现请求URL中最后一段数字是在不断变化的：\n查询网页内部的js文件发现，该串数字和时间有关，因此大胆猜测这段数字可能是时间戳，采用代码测试：\n1 2 3 4 5 6 import time def generate_timestamp(): \u0026#34;\u0026#34;\u0026#34;生成13位时间戳\u0026#34;\u0026#34;\u0026#34; return str(int(time.time() * 1000)) print(generate_timestamp()) #output-\u0026gt;1755764369564 代码测试结果与URL的末端数字相似，因此得证。但在爬取的过程中，发现在未登录状态下只能浏览前10页内容。因此需要解决登录问题，找到相关请求：\n根据相关字段向该URL提交表单并获取登录后的Cookie，但用Python获取Cookie后发现依旧无法获取，返回的结果：\n一开始我怀疑是获取的Cookie有问题，因此使用代码分析直接从网页上获取的Cookie的变化，试图找到规律：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from difflib import SequenceMatcher #将Cookie进行切割 def Cookie_split(Cookie): fragments = Cookie.split(\u0026#34;; \u0026#34;) dic = {} for fragment in fragments: key,value = fragment.split(\u0026#39;=\u0026#39;,1) dic[key] = value return dic def compare_strings(str1,str2): matcher = SequenceMatcher(None,str1,str2) for op , i1 , i2 ,j1 ,j2 in matcher.get_opcodes(): if op == \u0026#39;replace\u0026#39;: print(f\u0026#34;在位置{i1}替换了“{str1[i1:i2]}”为“{str2[j1:j2]}”\u0026#34;) elif op == \u0026#39;delete\u0026#39;: print(f\u0026#34;在位置{i1}删除了“{str1[i1:i2]}”\u0026#34;) elif op == \u0026#39;insert\u0026#39;: print(f\u0026#34;在位置{i1}插入了“{str1[i1:i2]}”\u0026#34;) #Cookie比较 def Cookie_compare(Cookie1,Cookie2): \u0026#34;\u0026#34;\u0026#34;比较两个Cookie的差别\u0026#34;\u0026#34;\u0026#34; cookie_dic1 = Cookie_split(Cookie1) cookie_dic2 = Cookie_split(Cookie2) key_list1 = cookie_dic1.keys() key_list2 = cookie_dic2.keys() print(key_list1) print(key_list2) # Cookie中属性的比较 diff = list(set(key_list1) ^ set(key_list2)) if diff == []: print(\u0026#34;两个Cookie在属性上一致\u0026#34;) for key in key_list1: print(f\u0026#34;|--------------------------{key}的差异点-------------------------|\u0026#34;) compare_strings(cookie_dic1[key],cookie_dic2[key]) print(f\u0026#34;|--------------------------------------------------------------|\u0026#34;) else: print(f\u0026#34;两个Cookie的属性差异：{diff}\u0026#34;) same_attribute = list(set(key_list1) \u0026amp; set(key_list2)) for key in same_attribute: print(f\u0026#34;|--------------------------{key}的差异点-------------------------|\u0026#34;) compare_strings(cookie_dic1[key],cookie_dic2[key]) print(f\u0026#34;|--------------------------------------------------------------|\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: Cookie_compare(Cookie6,Cookie7) 在比较的过程中发现，当网页保持登录状态时，从网页获取的Cookie可以正常使用，而当关闭网页后，之前获取的Cookie就失效了，因此怀疑整个流程如图：\n所以如果要保持Cookie的有效性，就必须保持登录状态。 因此考虑使用Selenium进行模拟登录，再从其中获取组成Cookie所需的相关字段。事实上，能直接获取的字段并不全，因此通过上面的比较代码，找到Cookie中的不变（有时不变）部分和变动（每次登录都会改变）部分，幸运的是变动部分都能在直接获取的字段中找到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def keep_connect(chrome_location,username,password): \u0026#34;\u0026#34;\u0026#34;使用selenium模拟登录，获取Cookie，并维持登录状态防止服务器端将Cookie注销\u0026#34;\u0026#34;\u0026#34; options = webdriver.ChromeOptions() options.binary_location = chrome_location options.add_argument(\u0026#34;ignore-certificate-errors\u0026#34;) options.add_experimental_option(\u0026#34;detach\u0026#34;, True) driver = webdriver.Chrome(options=options, executable_path=\u0026#39;../chromedriver.exe\u0026#39;) login_url = \u0026#39;https://account.chsi.com.cn/passport/login?service=https://www.ncss.cn/student/connect/chsi\u0026amp;entrytype=stu\u0026#39; driver.get(login_url) time.sleep(1) acc_input = driver.find_element(By.XPATH, r\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/input\u0026#39;) acc_input.send_keys(username) pwd_input = driver.find_element(By.XPATH, f\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/input\u0026#39;) pwd_input.send_keys(password) driver.find_element(By.XPATH, r\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[4]\u0026#39;).click() element = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, r\u0026#34;/html/body/div/span/span/a[1]\u0026#34;))) element.click() dic = {} for i in driver.get_cookies(): dic[i[\u0026#39;name\u0026#39;]] = i[\u0026#39;value\u0026#39;] return dic def Cookie_concat(got_property): \u0026#34;\u0026#34;\u0026#34;将从keep_connect函数中获取到的Cookie数据进行重新包装\u0026#34;\u0026#34;\u0026#34; changed_property_list = [\u0026#39;SESSION\u0026#39;, \u0026#39;Hm_lpvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;, \u0026#39;_ga\u0026#39;,\u0026#39;_ga_6CXWRD3K0D\u0026#39;] no_change = { \u0026#39;_ga_1ESVLDHDYL\u0026#39;: \u0026#39;GS1.1.1726503021.3.0.1726503021.0.0.0\u0026#39;, \u0026#39;_abfpc\u0026#39;: \u0026#39;d7760a7e8d00953eaa18b111273b00d6ad83f1cc_2.0\u0026#39;, \u0026#39;cna\u0026#39;: \u0026#39;eac1e178d67b00529df2b287b5842f2c\u0026#39;, \u0026#39;_gid\u0026#39;: \u0026#39;GA1.2.673435621.1755336171\u0026#39;, \u0026#39;aliyungf_tc\u0026#39;: \u0026#39;bfc4565f794c9e6ac253a5c09f4a937f2afb69e01fc7b413d486aaeaadf06249\u0026#39;, \u0026#39;XSRF-CCKTOKEN\u0026#39;: \u0026#39;a12b3436b08549ba2f33a4aefa9a1454\u0026#39;, \u0026#39;CHSICC_CLIENTFLAGNCSS\u0026#39;: \u0026#39;aba5b818eaa8bc94d6fb1ddf17d1df4f\u0026#39;, \u0026#39;CHSICC01\u0026#39;: \u0026#39;!DzrVNB/pHD1H78bzYxYLahOzddj6Y4XQ6NJ5RnOPIOyzHzKixC+5X5WINIjztT+S4x5PGaf/cowaI/Q=\u0026#39;, \u0026#39;CHSICC_CLIENTFLAGSTUDENT\u0026#39;: \u0026#39;5d0ab9cce044f18a699886e7d6705555\u0026#39;, \u0026#39;Hm_lvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;: \u0026#39;1754926580,1754968150,1755336169,1755411478\u0026#39;, \u0026#39;HMACCOUNT\u0026#39;: \u0026#39;CEB955474E107530\u0026#39;, \u0026#39;acw_tc\u0026#39;: \u0026#39;ac11000117554230396983911ee7b259a823321b52a20a878c0b42ee677273\u0026#39;, \u0026#39;_gat_gtag_UA_105074615_1\u0026#39;: \u0026#39;1\u0026#39; } property_all = no_change.copy() for i in changed_property_list: property_all[i] = got_property[i] property_rank = [\u0026#39;SESSION\u0026#39;,\u0026#39;_ga_1ESVLDHDYL\u0026#39;,\u0026#39;_abfpc\u0026#39;,\u0026#39;cna\u0026#39;,\u0026#39;_gid\u0026#39;,\u0026#39;aliyungf_tc\u0026#39;,\u0026#39;acw_tc\u0026#39;,\u0026#39;XSRF-CCKTOKEN\u0026#39;,\u0026#39;CHSICC_CLIENTFLAGNCSS\u0026#39;,\u0026#39;CHSICC01\u0026#39;,\u0026#39;CHSICC_CLIENTFLAGSTUDENT\u0026#39;,\u0026#39;Hm_lvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;,\u0026#39;HMACCOUNT\u0026#39;,\u0026#39;_gat_gtag_UA_105074615_1\u0026#39;,\u0026#39;Hm_lpvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;,\u0026#39;_ga\u0026#39;,\u0026#39;_ga_6CXWRD3K0D\u0026#39;] Cookie=\u0026#39;\u0026#39; for i in property_rank: Cookie = Cookie + i + \u0026#39;=\u0026#39; + property_all[i] + \u0026#39;; \u0026#39; print(\u0026#39;完成Cookie创建\u0026#39;) return Cookie def simulate_login_get_cookie(chrome_location,username,password): \u0026#34;\u0026#34;\u0026#34;将模拟登录部分和包装Cookie部分整合在一起\u0026#34;\u0026#34;\u0026#34; dic = keep_connect(chrome_location=chrome_location,username=username,password=password) return Cookie_concat(dic) 获取数据 ​\t数据分为两类，一类是岗位列表数据，另一类是岗位详情页数据。\n岗位列表数据 ​\t岗位列表数据即如图所示：\n该类数据可以直接从返回的响应中的\u0026quot;data\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;list\u0026quot;中找到，相关代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def get_job_data(http,Cookie,page=1,page_size=10): \u0026#34;\u0026#34;\u0026#34;获取岗位数据\u0026#34;\u0026#34;\u0026#34; baseurl = \u0026#34;https://www.ncss.cn/student/jobs/jobslist/ajax/\u0026#34; #构造请求头 headers = { \u0026#39;User-Agent\u0026#39;:ua.random, \u0026#39;Connection\u0026#39;:\u0026#39;keep-alive\u0026#39;, \u0026#39;Cookie\u0026#39;:Cookie, \u0026#34;Accept\u0026#34;: \u0026#34;application/json,*/*\u0026#34;, \u0026#39;Referer\u0026#39;:\u0026#34;https://account.chsi.com.cn/passport/login?service=https://job.ncss.cn/student/connect/chsi\u0026amp;entrytype=stu\u0026#34; } # 查询参数 params = { \u0026#34;jobType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;areaCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;jobName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;monthPay\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;industrySectors\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;property\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;categoryCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;memberLevel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;recruitType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;offset\u0026#34;: page, \u0026#34;limit\u0026#34;: page_size, \u0026#34;keyUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;degreeCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;sourcesName\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;sourcesType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;_\u0026#34;: generate_timestamp() # 动态时间戳 } try: resp = http.request( method=\u0026#39;GET\u0026#39;, url=baseurl, fields=params, headers=headers ) if resp.status in [403,401]: print(f\u0026#34;请求第{page}页时登录过期\u0026#34;) return None elif resp.status == 200: data = json.loads(resp.data.decode(\u0026#39;UTF-8\u0026#39;)) return data[\u0026#39;data\u0026#39;][\u0026#39;list\u0026#39;] else: print(f\u0026#34;请求第{page}页时错误，状态码{resp.status}\u0026#34;) return None except Exception as e: print(f\u0026#34;请求第{page}页时发生错误:{e}\u0026#34;) return None 详情页数据 ​\t详情页数据主要为详情页中的岗位介绍部分：\n该部分主要是使用BeautifulSoup对返回的结果进行解析，找到相关属性内容的位置并进行解析，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def fetch_detail_page(job_id,http,Cookie): \u0026#34;\u0026#34;\u0026#34;获取详情页数据\u0026#34;\u0026#34;\u0026#34; headers = { \u0026#39;User-Agent\u0026#39;:ua.random, \u0026#39;Cookie\u0026#39;:Cookie, \u0026#39;Referer\u0026#39;:\u0026#39;https://job.ncss.cn/student/jobs/index.html\u0026#39; } detail_url = f\u0026#34;https://www.ncss.cn/student/jobs/{job_id}/detail.html\u0026#34; try: resp = http.request( \u0026#39;GET\u0026#39;, detail_url, headers = headers ) if resp.status == 200: return resp.data.decode(\u0026#39;utf-8\u0026#39;) elif resp.status in [401,403]: print(f\u0026#34;获取{job_id}详情页时登录过期\u0026#34;) return None else: print(f\u0026#34;请求失败，状态码{resp.status}\u0026#34;) return None except Exception as e: print(f\u0026#34;请求失败，{str(e)}\u0026#34;) return None def pares_detail_job_info(html,job_info): \u0026#34;\u0026#34;\u0026#34;将爬取到的详情页进行解析，获取“岗位介绍”部分的数据\u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(html,\u0026#39;html.parser\u0026#39;) job_detail_describe_div =soup.find(name=\u0026#39;pre\u0026#39;,attrs={\u0026#39;class\u0026#39;:\u0026#34;mainContent mainContent\u0026#34;}) job_detail_describe = job_detail_describe_div.getText() job_info.update({ \u0026#34;岗位介绍\u0026#34;:job_detail_describe }) return job_info 效率与反爬 ​\t考虑到爬取的数据量稍多，因此使用Urllib3进行分布式爬取，一个主进程，两个工作线程（岗位列表和详情页），采用消费者-生产者模型，同时使用fake_useragent模块不断改变User-Agent的值，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def process_manager(total_pages,http,Cookie,num_list_workers=2,num_detail_workers=8,output_address=\u0026#34;\u0026#34;): \u0026#34;\u0026#34;\u0026#34;进程管理器（主进程）\u0026#34;\u0026#34;\u0026#34; global enqueued_jobs_count start_time = time.time() print(f\u0026#34;开始爬取任务，总页数: {total_pages}\u0026#34;) #创建Manager with Manager() as manager: #创建队列 list_page_queue = manager.Queue() detail_task_queue = manager.Queue(maxsize=5000) result_queue = manager.Queue() #添加列表页任务 for page in range(1,total_pages+1): list_page_queue.put(page) expected_total_list_pages = total_pages expected_total_detail_jobs = total_pages * 10 #进度条 list_pbar = tqdm(total=expected_total_list_pages,desc=\u0026#39;列表页\u0026#39;,unit=\u0026#39;页\u0026#39;,dynamic_ncols=True,file=sys.stdout) detail_pbar = tqdm(total=expected_total_detail_jobs,desc=\u0026#39;详情页\u0026#39;,unit=\u0026#39;项\u0026#39;,dynamic_ncols=True,file=sys.stdout) #创建并启动线程 threads = [] #列表页工作线程 for i in range(num_list_workers): t = threading.Thread( target=list_page_worker, args=(list_page_queue,http,Cookie,detail_task_queue,list_pbar), name=f\u0026#34;ListWorker-{i+1}\u0026#34;, daemon=True ) t.start() threads.append(t) #详情页工作线程 for i in range(num_detail_workers): t = threading.Thread( target=detail_page_worker, args=(detail_task_queue,result_queue,http,Cookie,detail_pbar), name=f\u0026#34;DetailWorker-{i+1}\u0026#34;, daemon=True ) t.start() threads.append(t) #结果写入线程 writer_thread = threading.Thread( target=result_writer, args=(result_queue,output_address), name=\u0026#34;ResultWriter\u0026#34;, daemon=True ) writer_thread.start() #等待列表页队列为空（等待完成列表页任务） list_page_queue.join() #通知列表页任务线程退出 for _ in range(num_list_workers): list_page_queue.put(None) print(f\u0026#34;所有列表页任务已完成,{num_list_workers}个工作线程已退出\u0026#34;) #调整详情任务总数 with progress_lock: actual_enqueued = enqueued_jobs_count if actual_enqueued \u0026gt; 0 and actual_enqueued \u0026lt; detail_pbar.total: detail_pbar.total = actual_enqueued detail_pbar.refresh() #等待详情页任务队列为空（详情页任务完成） detail_task_queue.join() #通知详情页工作线程退出 for _ in range(num_detail_workers): detail_task_queue.put(None) print(f\u0026#34;所有详情页任务已完成,{num_detail_workers}个工作线程已退出\u0026#34;) #通知结果写入线程退出 result_queue.put(None) for t in threads: t.join(timeout=10) writer_thread.join(timeout=10) elapsed_time = time.time() - start_time list_pbar.close() detail_pbar.close() print(f\u0026#34;爬取完成! 总耗时: {elapsed_time:.2f} 秒\u0026#34;) 项目流程图 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 import queue import random import threading import time from multiprocessing import Manager from bs4 import BeautifulSoup import urllib3 import json from tqdm.auto import tqdm import sys from fake_useragent import UserAgent from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.support.ui import WebDriverWait #抑制认证警告 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def keep_connect(chrome_location,username,password): \u0026#34;\u0026#34;\u0026#34;使用selenium模拟登录，获取Cookie，并维持登录状态防止服务器端将Cookie注销\u0026#34;\u0026#34;\u0026#34; options = webdriver.ChromeOptions() options.binary_location = chrome_location options.add_argument(\u0026#34;ignore-certificate-errors\u0026#34;) options.add_argument(\u0026#34;--headless\u0026#34;) options.add_argument(\u0026#34;--disable-gpu\u0026#34;) options.add_argument(\u0026#34;--disable-software-rasterizer\u0026#34;) options.add_experimental_option(\u0026#34;detach\u0026#34;, True) driver = webdriver.Chrome(options=options,executable_path=\u0026#39;../chromedriver.exe\u0026#39;) login_url = \u0026#39;https://account.chsi.com.cn/passport/login?service=https://www.ncss.cn/student/connect/chsi\u0026amp;entrytype=stu\u0026#39; driver.get(login_url) time.sleep(1) acc_input = driver.find_element(By.XPATH, r\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[1]/input\u0026#39;) acc_input.send_keys(username) pwd_input = driver.find_element(By.XPATH, f\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[2]/input\u0026#39;) pwd_input.send_keys(password) driver.find_element(By.XPATH, r\u0026#39;/html/body/div/div[2]/div[2]/div/div[2]/form/div[4]\u0026#39;).click() element = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, r\u0026#34;/html/body/div/span/span/a[1]\u0026#34;))) element.click() dic = {} for i in driver.get_cookies(): dic[i[\u0026#39;name\u0026#39;]] = i[\u0026#39;value\u0026#39;] return dic def Cookie_concat(got_property): \u0026#34;\u0026#34;\u0026#34;将从keep_connect函数中获取到的Cookie数据进行重新包装\u0026#34;\u0026#34;\u0026#34; changed_property_list = [\u0026#39;SESSION\u0026#39;, \u0026#39;Hm_lpvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;, \u0026#39;_ga\u0026#39;,\u0026#39;_ga_6CXWRD3K0D\u0026#39;] no_change = { \u0026#39;_ga_1ESVLDHDYL\u0026#39;: \u0026#39;GS1.1.1726503021.3.0.1726503021.0.0.0\u0026#39;, \u0026#39;_abfpc\u0026#39;: \u0026#39;d7760a7e8d00953eaa18b111273b00d6ad83f1cc_2.0\u0026#39;, \u0026#39;cna\u0026#39;: \u0026#39;eac1e178d67b00529df2b287b5842f2c\u0026#39;, \u0026#39;_gid\u0026#39;: \u0026#39;GA1.2.673435621.1755336171\u0026#39;, \u0026#39;aliyungf_tc\u0026#39;: \u0026#39;bfc4565f794c9e6ac253a5c09f4a937f2afb69e01fc7b413d486aaeaadf06249\u0026#39;, \u0026#39;XSRF-CCKTOKEN\u0026#39;: \u0026#39;a12b3436b08549ba2f33a4aefa9a1454\u0026#39;, \u0026#39;CHSICC_CLIENTFLAGNCSS\u0026#39;: \u0026#39;aba5b818eaa8bc94d6fb1ddf17d1df4f\u0026#39;, \u0026#39;CHSICC01\u0026#39;: \u0026#39;!DzrVNB/pHD1H78bzYxYLahOzddj6Y4XQ6NJ5RnOPIOyzHzKixC+5X5WINIjztT+S4x5PGaf/cowaI/Q=\u0026#39;, \u0026#39;CHSICC_CLIENTFLAGSTUDENT\u0026#39;: \u0026#39;5d0ab9cce044f18a699886e7d6705555\u0026#39;, \u0026#39;Hm_lvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;: \u0026#39;1754926580,1754968150,1755336169,1755411478\u0026#39;, \u0026#39;HMACCOUNT\u0026#39;: \u0026#39;CEB955474E107530\u0026#39;, \u0026#39;acw_tc\u0026#39;: \u0026#39;ac11000117554230396983911ee7b259a823321b52a20a878c0b42ee677273\u0026#39;, \u0026#39;_gat_gtag_UA_105074615_1\u0026#39;: \u0026#39;1\u0026#39; } property_all = no_change.copy() for i in changed_property_list: property_all[i] = got_property[i] property_rank = [\u0026#39;SESSION\u0026#39;,\u0026#39;_ga_1ESVLDHDYL\u0026#39;,\u0026#39;_abfpc\u0026#39;,\u0026#39;cna\u0026#39;,\u0026#39;_gid\u0026#39;,\u0026#39;aliyungf_tc\u0026#39;,\u0026#39;acw_tc\u0026#39;,\u0026#39;XSRF-CCKTOKEN\u0026#39;,\u0026#39;CHSICC_CLIENTFLAGNCSS\u0026#39;,\u0026#39;CHSICC01\u0026#39;,\u0026#39;CHSICC_CLIENTFLAGSTUDENT\u0026#39;,\u0026#39;Hm_lvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;,\u0026#39;HMACCOUNT\u0026#39;,\u0026#39;_gat_gtag_UA_105074615_1\u0026#39;,\u0026#39;Hm_lpvt_378ff17a1ac046691cf78376632d1ed4\u0026#39;,\u0026#39;_ga\u0026#39;,\u0026#39;_ga_6CXWRD3K0D\u0026#39;] Cookie=\u0026#39;\u0026#39; for i in property_rank: Cookie = Cookie + i + \u0026#39;=\u0026#39; + property_all[i] + \u0026#39;; \u0026#39; print(\u0026#34;------------------完成Cookie创建------------------\u0026#34;) return Cookie def simulate_login_get_cookie(chrome_location,username,password): \u0026#34;\u0026#34;\u0026#34;将模拟登录部分和包装Cookie部分整合在一起\u0026#34;\u0026#34;\u0026#34; dic = keep_connect(chrome_location=chrome_location,username=username,password=password) return Cookie_concat(dic) ua = UserAgent() def generate_timestamp(): \u0026#34;\u0026#34;\u0026#34;生成13位时间戳\u0026#34;\u0026#34;\u0026#34; return str(int(time.time() * 1000)) def get_job_data(http,Cookie,page=1,page_size=10): \u0026#34;\u0026#34;\u0026#34;获取岗位数据\u0026#34;\u0026#34;\u0026#34; baseurl = \u0026#34;https://www.ncss.cn/student/jobs/jobslist/ajax/\u0026#34; #构造请求头 headers = { \u0026#39;User-Agent\u0026#39;:ua.random, \u0026#39;Connection\u0026#39;:\u0026#39;keep-alive\u0026#39;, \u0026#39;Cookie\u0026#39;:Cookie, \u0026#34;Accept\u0026#34;: \u0026#34;application/json,*/*\u0026#34;, \u0026#39;Referer\u0026#39;:\u0026#34;https://account.chsi.com.cn/passport/login?service=https://job.ncss.cn/student/connect/chsi\u0026amp;entrytype=stu\u0026#34; } # 查询参数 params = { \u0026#34;jobType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;areaCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;jobName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;monthPay\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;industrySectors\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;property\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;categoryCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;memberLevel\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;recruitType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;offset\u0026#34;: page, \u0026#34;limit\u0026#34;: page_size, \u0026#34;keyUnits\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;degreeCode\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;sourcesName\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;sourcesType\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;_\u0026#34;: generate_timestamp() # 动态时间戳 } try: resp = http.request( method=\u0026#39;GET\u0026#39;, url=baseurl, fields=params, headers=headers ) if resp.status in [403,401]: tqdm.write(f\u0026#34;请求第{page}页时登录过期\u0026#34;) return None elif resp.status == 200: data = json.loads(resp.data.decode(\u0026#39;UTF-8\u0026#39;)) return data[\u0026#39;data\u0026#39;][\u0026#39;list\u0026#39;] else: tqdm.write(f\u0026#34;请求第{page}页时错误，状态码{resp.status}\u0026#34;) return None except Exception as e: tqdm.write(f\u0026#34;请求第{page}页时发生错误:{e}\u0026#34;) return None def fetch_detail_page(job_id,http,Cookie): \u0026#34;\u0026#34;\u0026#34;获取详情页数据\u0026#34;\u0026#34;\u0026#34; headers = { \u0026#39;User-Agent\u0026#39;:ua.random, \u0026#39;Cookie\u0026#39;:Cookie, \u0026#39;Referer\u0026#39;:\u0026#39;https://job.ncss.cn/student/jobs/index.html\u0026#39; } detail_url = f\u0026#34;https://www.ncss.cn/student/jobs/{job_id}/detail.html\u0026#34; try: resp = http.request( \u0026#39;GET\u0026#39;, detail_url, headers = headers ) if resp.status == 200: return resp.data.decode(\u0026#39;utf-8\u0026#39;) elif resp.status in [401,403]: tqdm.write(f\u0026#34;获取{job_id}详情页时登录过期\u0026#34;) return None else: tqdm.write(f\u0026#34;请求失败，状态码{resp.status}\u0026#34;) return None except Exception as e: tqdm.write(f\u0026#34;请求失败，{str(e)}\u0026#34;) return None def pares_detail_job_info(html,job_info): \u0026#34;\u0026#34;\u0026#34;将爬取到的详情页进行解析，获取“岗位介绍”部分的数据\u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(html,\u0026#39;html.parser\u0026#39;) job_detail_describe_div =soup.find(name=\u0026#39;div\u0026#39;,attrs={\u0026#39;class\u0026#39;:\u0026#34;details\u0026#34;}) if job_detail_describe_div is not None: job_detail_describe = job_detail_describe_div.getText() else: tqdm.write(f\u0026#34;未找到岗位描述元素，岗位ID:{job_info.get(\u0026#39;岗位ID\u0026#39;)}\u0026#34;) job_detail_describe = \u0026#34;未知\u0026#34; job_info.update({ \u0026#34;岗位介绍\u0026#34;:job_detail_describe }) return job_info def parse_job_info(job): \u0026#34;\u0026#34;\u0026#34;解析岗位信息\u0026#34;\u0026#34;\u0026#34; id = job.get(\u0026#34;jobId\u0026#34;) timeStamp = job.get(\u0026#34;updateDate\u0026#34;) timeArray = time.localtime(float(timeStamp)/1000) return { \u0026#34;岗位ID\u0026#34;:id, \u0026#34;职位名称\u0026#34;:job.get(\u0026#34;jobName\u0026#34;), \u0026#34;薪资水平\u0026#34;:str(job.get(\u0026#34;lowMonthPay\u0026#34;))+\u0026#39;k-\u0026#39;+str(job.get(\u0026#39;highMonthPay\u0026#39;))+\u0026#39;k\u0026#39;, \u0026#34;招聘人数\u0026#34;:job.get(\u0026#34;headCount\u0026#34;), \u0026#34;学历要求\u0026#34;:job.get(\u0026#34;degreeName\u0026#34;), \u0026#34;招聘方\u0026#34;:job.get(\u0026#34;recName\u0026#34;), \u0026#34;公司规模\u0026#34;:job.get(\u0026#34;recScale\u0026#34;), \u0026#34;地区\u0026#34;:job.get(\u0026#34;areaCodeName\u0026#34;), \u0026#34;福利\u0026#34;:job.get(\u0026#34;recTags\u0026#34;), \u0026#34;专业要求\u0026#34;:job.get(\u0026#34;major\u0026#34;), \u0026#34;岗位更新时间\u0026#34;:time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;,timeArray), \u0026#34;详情网址\u0026#34;:f\u0026#34;https://www.ncss.cn/student/jobs/{id}/detail.html\u0026#34; } def list_page_worker(list_page_queue, http, Cookie, detail_task_queue, list_pbar): \u0026#34;\u0026#34;\u0026#34;获取岗位列表的工作流程\u0026#34;\u0026#34;\u0026#34; global list_get_wrong, list_pages_done, enqueued_jobs_count while True: page = None try: page = list_page_queue.get(timeout=30) if page is None: list_page_queue.task_done() # 对应主线程 put(None) break # 爬取列表页 jobs = get_job_data(http=http, Cookie=Cookie, page=page, page_size=10) if jobs: for job in jobs: job_info = parse_job_info(job) detail_task_queue.put(job_info) with progress_lock: enqueued_jobs_count += 1 time.sleep(random.uniform(0.5, 1.5)) except queue.Empty: thread_name = threading.current_thread().name tqdm.write(f\u0026#34;列表页任务队列空，线程 {thread_name} 准备退出\u0026#34;) continue except Exception as e: tqdm.write(f\u0026#34;列表页工作线程异常: {str(e)}\u0026#34;) if page: list_get_wrong.append(page) time.sleep(5) finally: if page is not None: # 只在真实任务时更新 list_pages_done += 1 list_pbar.update(1) list_page_queue.task_done() def detail_page_worker(detail_task_queue,result_queue,http,Cookie,detail_pbar): \u0026#34;\u0026#34;\u0026#34;详情页工作流程\u0026#34;\u0026#34;\u0026#34; global detail_get_wrong,detail_jobs_done while True: job_info = None job_id =None try: job_info = detail_task_queue.get(timeout=30) if job_info is None: detail_task_queue.task_done() break job_id = job_info.get(\u0026#34;岗位ID\u0026#34;) # print(f\u0026#34;开始爬取详情页{job_id}\u0026#34;) html = fetch_detail_page(job_id, http, Cookie) if html: new_job_info = pares_detail_job_info(html, job_info) result_queue.put(new_job_info) # print(f\u0026#34;详情页{job_id}解析完成\u0026#34;) else: tqdm.write(f\u0026#34;详情页{job_id}爬取失败\u0026#34;) time.sleep(random.uniform(0.3, 0.8)) except queue.Empty: thread_name = threading.current_thread().name tqdm.write(f\u0026#34;详情页任务队列空，线程{thread_name}准备退出\u0026#34;) continue except Exception as e: tqdm.write(f\u0026#34;详情页工作线程异常: {str(e)}\u0026#34;) if job_id: detail_get_wrong.append(job_id) time.sleep(3) finally: if job_info is not None: detail_jobs_done += 1 detail_pbar.update(1) detail_task_queue.task_done() def result_writer(result_queue, output_address): \u0026#34;\u0026#34;\u0026#34;结果写入线程\u0026#34;\u0026#34;\u0026#34; struc_time = time.localtime() time_year = struc_time.tm_year time_month = struc_time.tm_mon time_day = struc_time.tm_mday output_file = output_address + f\u0026#39;{time_year}_{time_month}_{time_day}_jobs\u0026#39; count = 0 with open(output_file, \u0026#34;a\u0026#34;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\u0026#39;) as f: while True: try: # 获取结果 result = result_queue.get(timeout=120) if result is None: break f.write(json.dumps(result, ensure_ascii=False) + \u0026#34;\\n\u0026#34;) f.flush() count += 1 if count % 100 == 0: tqdm.write(f\u0026#34;已写入 {count} 条结果\u0026#34;) result_queue.task_done() except queue.Empty: tqdm.write(\u0026#34;结果写入线程超时退出\u0026#34;) break except Exception as e: tqdm.write(f\u0026#34;结果写入异常: {str(e)}\u0026#34;) tqdm.write(f\u0026#34;结果写入完成，共写入 {count} 条数据\u0026#34;) def process_manager(total_pages,http,Cookie,num_list_workers=2,num_detail_workers=8,output_address=\u0026#34;\u0026#34;): \u0026#34;\u0026#34;\u0026#34;进程管理器（主进程）\u0026#34;\u0026#34;\u0026#34; global enqueued_jobs_count start_time = time.time() tqdm.write(f\u0026#34;开始爬取任务，总页数: {total_pages}\u0026#34;) #创建Manager with (Manager() as manager): #创建队列 list_page_queue = manager.Queue() detail_task_queue = manager.Queue(maxsize=5000) result_queue = manager.Queue() #添加列表页任务 for page in range(1,total_pages+1): list_page_queue.put(page) expected_total_list_pages = total_pages expected_total_detail_jobs = total_pages * 10 #进度条 list_pbar = tqdm(total=expected_total_list_pages,desc=\u0026#39;列表页\u0026#39;,unit=\u0026#39;页\u0026#39;,dynamic_ncols=True,file=sys.stdout) detail_pbar = tqdm(total=expected_total_detail_jobs,desc=\u0026#39;详情页\u0026#39;,unit=\u0026#39;项\u0026#39;,dynamic_ncols=True,file=sys.stdout) #创建并启动线程 threads = [] #列表页工作线程 for i in range(num_list_workers): t = threading.Thread( target=list_page_worker, args=(list_page_queue,http,Cookie,detail_task_queue,list_pbar), name=f\u0026#34;ListWorker-{i+1}\u0026#34;, daemon=True ) t.start() threads.append(t) #详情页工作线程 for i in range(num_detail_workers): t = threading.Thread( target=detail_page_worker, args=(detail_task_queue,result_queue,http,Cookie,detail_pbar), name=f\u0026#34;DetailWorker-{i+1}\u0026#34;, daemon=True ) t.start() threads.append(t) #结果写入线程 writer_thread = threading.Thread( target=result_writer, args=(result_queue,output_address), name=\u0026#34;ResultWriter\u0026#34;, daemon=True ) writer_thread.start() #等待列表页队列为空（等待完成列表页任务） list_page_queue.join() #通知列表页任务线程退出 for _ in range(num_list_workers): list_page_queue.put(None) tqdm.write(f\u0026#34;所有列表页任务已完成,{num_list_workers}个工作线程已退出\u0026#34;) #调整详情任务总数 with progress_lock: actual_enqueued = enqueued_jobs_count if actual_enqueued \u0026gt; 0 and actual_enqueued \u0026lt; detail_pbar.total: detail_pbar.total = actual_enqueued detail_pbar.refresh() #等待详情页任务队列为空（详情页任务完成） detail_task_queue.join() #通知详情页工作线程退出 for _ in range(num_detail_workers): detail_task_queue.put(None) tqdm.write(f\u0026#34;所有详情页任务已完成,{num_detail_workers}个工作线程已退出\u0026#34;) #通知结果写入线程退出 result_queue.put(None) for t in threads: t.join(timeout=10) writer_thread.join(timeout=10) elapsed_time = time.time() - start_time list_pbar.close() detail_pbar.close() print(f\u0026#34;爬取完成! 总耗时: {elapsed_time:.2f} 秒\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: #全局变量 progress_lock = threading.Lock() list_pages_done = 0 detail_jobs_done =0 enqueued_jobs_count = 0 # 配置爬取参数 TOTAL_PAGES = 200 # 要爬取的列表页总数 NUM_LIST_WORKERS = 2 # 列表页工作线程数 NUM_DETAIL_WORKERS = 5 # 详情页工作线程数 OUTPUT_ADDRESS = \u0026#34;\u0026#34; # 输出文件的地址，默认为项目地址 #配置模拟登录参数 chrome_location = r\u0026#39;D:\\python_project\\Google\\Chrome\\Application\\chrome.exe\u0026#39; #chrome启动器的位置 username = \u0026#34;\u0026#34; #模拟登录的账号 password = \u0026#34;\u0026#34;#模拟登陆的密码 detail_get_wrong = [] #获取详情失败的job_id list_get_wrong = [] #获取岗位失败的页码 #构建连接池 print(\u0026#34;------------------开始构建连接池------------------\u0026#34;) http = urllib3.PoolManager( num_pools=50, maxsize=50, cert_reqs=\u0026#39;CERT_NONE\u0026#39;, assert_hostname=False, block=True, timeout=urllib3.Timeout(connect=5.0, read=10.0), retries=urllib3.Retry(total=3, backoff_factor=0.5), ) print(\u0026#34;------------------完成构建连接池------------------\u0026#34;) #模拟登录，维持登录状态，获取组成Cookie的必要的参数 print(\u0026#34;-------------------开始模拟登录-------------------\u0026#34;) Cookie = simulate_login_get_cookie(chrome_location=chrome_location,username=username,password=password) print(\u0026#34;-------------------完成模拟登录-------------------\u0026#34;) # 启动爬虫 print(\u0026#34;-------------------开始网络爬取-------------------\u0026#34;) process_manager( total_pages=TOTAL_PAGES, num_list_workers=NUM_LIST_WORKERS, num_detail_workers=NUM_DETAIL_WORKERS, output_address=OUTPUT_ADDRESS, http = http, Cookie = Cookie ) print(\u0026#34;-------------------完成网络爬取-------------------\u0026#34;) 问题 OR 改进 当前的爬取仍需要登录才能获取，如何才能以非登录状态获取所需的数据 可以增加代理，从而不断变动IP使得不易被锁IP ","date":"2025-08-20T17:47:51+08:00","image":"https://Entars.github.io/p/%E5%9B%BD%E5%AE%B6%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%B0%B1%E4%B8%9A%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E5%B2%97%E4%BD%8D%E7%88%AC%E5%8F%96/national_college_employment_platform_hu_a3782813dccbc16d.png","permalink":"https://Entars.github.io/p/%E5%9B%BD%E5%AE%B6%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%B0%B1%E4%B8%9A%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E5%B2%97%E4%BD%8D%E7%88%AC%E5%8F%96/","title":"国家大学生就业服务平台岗位爬取"},{"content":"BeautifulSoup 简介 BeautifulSoup 是一个可以把 HTML 或 XML 文档“变成结构化树”，方便你用Python 来查找、遍历、提取内容的工具。\n解析器 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, \u0026lsquo;html.parser\u0026rsquo;) python内置的标准库，执行速度适中 Python3.2.2之前的版本容错能力差 lxml HTML解析器 BeautifulSoup(markup, \u0026rsquo;lxml') 速度快、文档容错能力强 需要安装C语言库 lxml XML解析器 BeautifulSoup(markup \u0026lsquo;xml\u0026rsquo;) 速度快，唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, \u0026lsquo;html5lib\u0026rsquo;) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢，不依赖外部拓展 具体使用代码展示如下：\n1 2 3 4 from bs4 import BeautifulSoup soup = BeautifulSoup(\u0026#39;\u0026lt;p\u0026gt;Hello world\u0026lt;/p\u0026gt;\u0026#39;, \u0026#39;lxml\u0026#39;) print(soup.p) 基本用法 当传入不标准的HTML字符串，BeautifulSoup可以自动更正格式。\nsoup.prettify(): 用于将 HTML 或 XML 文档格式化输出为带缩进的字符串,即会把原始网页内容重新排版，输出一个带有层级缩进的漂亮 HTML 字符串，例：\n1 2 3 4 5 6 7 from bs4 import BeautifulSoup html = \u0026#39;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Test\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hi\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39; soup = BeautifulSoup(html, \u0026#39;html.parser\u0026#39;) pretty_html = soup.prettify() print(pretty_html) 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; Test \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; Hi \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Hello \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; .title：获取title标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 html_doc=\u0026#34;\u0026#34;\u0026#34; \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were \u0026lt;a href=\u0026#34;http://example.com/elsie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a href=\u0026#34;http://example.com/lacie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and \u0026lt;a href=\u0026#34;http://example.com/tillie\u0026#34; class=\u0026#34;sister\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; and they lived at the bottom of a well.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; \u0026#34;\u0026#34;\u0026#34;\u0026#34; # 创建beautifulsoup对象 解析器为lxml soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.title) #output-\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; .name：返回的是当前节点的“标签名称”\n1 2 3 4 5 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.title.name) print(soup.name) #output-\u0026gt;title #[document] .string/.text：获取标签中的文字内容\n1 2 3 4 5 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.title.string) print(soup.title.text) #output-\u0026gt;The Dormouse\u0026#39;s story #The Dormouse\u0026#39;s story .p：访问HTML中第一个标签\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.p) #output-\u0026gt;\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; .find_all()：查找文档中所有符合条件的标签元素，返回一个列表\n用法 示例 说明 查找所有某种标签 soup.find_all(\u0026lsquo;p\u0026rsquo;) 找出所有 \u0026lt;p\u0026gt; 根据 class 属性 soup.find_all(\u0026lsquo;p\u0026rsquo;, class_=\u0026lsquo;story\u0026rsquo;) class 要用 class_ 表示 查找多个标签 soup.find_all([\u0026lsquo;p\u0026rsquo;, \u0026lsquo;a\u0026rsquo;]) 所有 \u0026lt;p\u0026gt; 和 \u0026lt;a\u0026gt; 标签 查找包含特定字符串的标签 soup.find_all(string=\u0026lsquo;Hello\u0026rsquo;) 内容匹配为 \u0026lsquo;Hello\u0026rsquo; 的标签 使用属性字典 soup.find_all(\u0026lsquo;a\u0026rsquo;, {\u0026lsquo;id\u0026rsquo;: \u0026rsquo;link1\u0026rsquo;}) 属性筛选 限制返回数量 soup.find_all(\u0026lsquo;p\u0026rsquo;, limit=2) 最多返回 2 个 \u0026lt;p\u0026gt; 标签 1 2 3 4 \u0026#39;\u0026#39;\u0026#39; 基本语法： soup.find_all(name=None, attrs={}, recursive=True, string=None, limit=None, **kwargs) \u0026#39;\u0026#39;\u0026#39; .find()：获取第一次匹配条件的元素\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.find(id=\u0026#34;link1\u0026#34;)) #output-\u0026gt;\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt; .parent：获取父级标签\n1 2 3 4 5 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.title) print(soup.title.parnt) #output-\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt; #\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; .p[\u0026lsquo;class\u0026rsquo;]：获取某个 \u0026lt;p\u0026gt; 标签的 class 属性的值\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.p[\u0026#34;class\u0026#34;]) #output-\u0026gt;[\u0026#39;title\u0026#39;] .get_text()：获取文档中所有文字内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.get_text()) \u0026#39;\u0026#39;\u0026#39; output-\u0026gt; The Dormouse\u0026#39;s story The Dormouse\u0026#39;s story Once upon a time there were three little sisters; and their names were Elsie, Lacie and Tillie; and they lived at the bottom of a well. ... \u0026#39;\u0026#39;\u0026#39; .get()：用于安全地获取某个属性的值\n1 2 3 4 5 6 7 8 9 \u0026#39;\u0026#39;\u0026#39; tag.get(\u0026#39;属性名\u0026#39;) 相当于 tag[\u0026#39;属性名\u0026#39;]，但如果属性不存在，不会报错，而是返回 None \u0026#39;\u0026#39;\u0026#39; a_tags = soup.find_all(\u0026#39;a\u0026#39;) for a_tag in a_tags: print(a_tag.get(\u0026#34;href\u0026#34;)) #output-\u0026gt;https://example.com/elsie #https://example.com/lacie #https://example.com/tillie BeautifulSoup的对象种类 主要有四种主要类型：Tag，NavigableString，BeautifulSoup，Comment。\nTag：该对象与HTML或XML原生文档中的标签相同，该对象可以包含其他标签，文本内容和属性。\n1 2 3 4 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) tag = soup.title print(type(tag)) #output-\u0026gt;\u0026lt;class \u0026#39;bs4.element.Tag\u0026#39;\u0026gt; NavigableString：标签中的文本内容，是一个不可变字符串，可以由Tag对象的.string获取\n1 2 3 4 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) tag = soup.title print(type(tag.string)) #output-\u0026gt; \u0026lt;class \u0026#39;bs4.element.NavigableString\u0026#39;\u0026gt; BeautifulSoup：整个文档的根对象，即整个文档的根内容，可以被视为一个特殊的Tag对象，但没有名称和属性，其提供对整个文档的遍历，搜索和修改\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(type(soup)) #output-\u0026gt; \u0026lt;class \u0026#39;bs4.BeautifulSoup\u0026#39;\u0026gt; Comment：对象是一个特殊类型的NavigableString对象,表示HTML和XML中的注释部分\n1 2 3 4 # \u0026lt;b\u0026gt;\u0026lt;!--This is a comment--\u0026gt;\u0026lt;/b\u0026gt; soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(type(soup.b.string)) #output-\u0026gt; \u0026lt;class \u0026#39;bs4.element.NavigableString\u0026#39;\u0026gt; BeautifulSoup遍历文档树 BeautifulSoup提供很多方法来遍历解析后的文档树\n导航父节点：.parent和.parents。其中.parent可以获取当前节点的上一级父节点，.parents可以遍历获取当前节点的所有父辈节点\n1 2 3 4 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) title_tag = soup.title print(title_tag.parent) #\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; 1 2 3 4 5 6 7 8 9 10 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) body_tag = soup.body for parent in body_tag.parents: print(parent) #\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; #\u0026lt;body\u0026gt; #\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; #\u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, #.... 导航子节点：.contents可以获取当前节点的所有子节点；.children可以遍历当前节点的所有子节点，返回一个list。字符串没有这两个属性。这两个仅包含tag直接子结点，字符串”The Dormouse\u0026rsquo;s story”是\u0026lt;head\u0026gt;标签的子孙结点\n1 2 3 4 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) head_contents = soup.head.contents print(head_contents) #output-\u0026gt; [\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;] 1 2 3 4 5 6 7 8 9 10 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) body_children = soup.body.children for child in body_children: print(child) #output-\u0026gt;\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/tillie\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;; #and they lived at the bottom of a well.\u0026lt;/p\u0026gt; #..... .descendants：可以遍历当前节点的所有后代节点（层遍历）\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) for descendant in soup.descendants: print(descendant) 节点内容：.string，.strings，.stripped_strings。.string如果如果tag只有一个NavigableString类型子节点,那么这个tag可以使用.string得到其子节点。但若tag中包含了多个子节点,tag就无法确定string方法应该调用哪一个字节的内容,则会输出None\n1 2 3 4 5 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.head.string) #The Dormouse\u0026#39;s story print(soup.title.string) #The Dormouse\u0026#39;s story 1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.body.string) #None .strings可以遍历获取标签中的所有文本内容，.stripped_strings可以去除多余的空白字符\n1 2 3 4 5 6 7 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) for string in soup.strings: print(string) #The Dormouse\u0026#39;s story ...... #The Dormouse\u0026#39;s story BeautifulSoup搜索文档树 find_all()：搜索当前tag的所有tag子节点\n1 2 3 4 5 6 7 8 9 10 11 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.find_all(\u0026#34;title\u0026#34;)) # 查找所有的title标签 print(soup.find_all(\u0026#34;p\u0026#34;, \u0026#34;title\u0026#34;)) # 查找p标签中class为title的标签 print(soup.find_all(\u0026#34;a\u0026#34;)) # 查找所有的a标签 print(soup.find_all(id=\u0026#34;link2\u0026#34;)) # 查找id为link2的标签 #[\u0026lt;title\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/title\u0026gt;] #[\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt;, \u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/tillie\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;] #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt;] find_parent()：只返回最接近的父标签\n1 2 3 4 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) a_string = soup.find(string=\u0026#39;Lacie\u0026#39;) print(a_string.find_parent()) # 查找父节点 #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; find_parents()：返回所有符合条件的祖先标签，按从近到远的顺序排列\n1 2 3 4 5 6 7 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) a_string = soup.find(string=\u0026#39;Lacie\u0026#39;) print(a_string.find_parents()) # 查找父节点 #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt;, \u0026lt;p class=\u0026#34;story\u0026#34;\u0026gt;Once upon a time there were three little sisters; and their names were #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, #\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt; and #and they lived at the bottom of a well.\u0026lt;/p\u0026gt;, \u0026lt;body\u0026gt;....] BeautifulSoup的CSS选择器 我们在写CSS时,标签名不加任何修饰,类名前加点,id名前加#,BeautifulSoup中也可以使用类似的方法来筛选元素。BeautifulSoup中的select()方法允许使用CSS选择器来查找HTML文档元素,其返回一个包含所有匹配元素的列表类似于find_all()方法。\n通过标签名查找：\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#39;b\u0026#39;)) #[\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;, \u0026lt;b\u0026gt;\u0026lt;!--This is a comment--\u0026gt;\u0026lt;/b\u0026gt;] 通过类名查找：\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#39;.title\u0026#39;)) #[\u0026lt;p class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;b\u0026gt;The Dormouse\u0026#39;s story\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;] id名查找：\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#39;#link1\u0026#39;)) #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;] 组合查找：组合查找即与写class时一致,标签名与类名id名进行组合的原理一样\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#39;p #link1\u0026#39;)) #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;] 属性查找：选择具有特定属性或属性值的标签\n简单属性选择器：\n1 2 3 soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#34;a[href=\u0026#39;https://example.com/elsie\u0026#39;]\u0026#34;)) # 选择a标签中href属性为https://example.com/elsie的标签 #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;] 属性值选择器\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026#39;\u0026#39;\u0026#39; 精确匹配:[attribute=\u0026#34;value\u0026#34;] 部分匹配 包含特定值:[attribute~=\u0026#34;value\u0026#34;] 选择属性值包含特定单词的标签。 以特定值开头:[attribute^=\u0026#34;value\u0026#34;] 选择属性值以特定字符串开头的标签 以特定值结尾:[attribute$=\u0026#34;value\u0026#34;] 选择属性值以特定字符串结尾的标签。 包含特定子字符串:[attribute*=\u0026#34;value\u0026#34;] 选择属性值包含特定子字符串的标签 \u0026#39;\u0026#39;\u0026#39; soup = BeautifulSoup(html_doc, \u0026#39;lxml\u0026#39;) print(soup.select(\u0026#39;a[href^=\u0026#34;https://example.com\u0026#34;]\u0026#39;)) # 选择href以https://example.com开头的a标签 #[\u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/elsie\u0026#34; id=\u0026#34;link1\u0026#34;\u0026gt;Elsie\u0026lt;/a\u0026gt;, \u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/lacie\u0026#34; id=\u0026#34;link2\u0026#34;\u0026gt;Lacie\u0026lt;/a\u0026gt;, \u0026lt;a class=\u0026#34;sister\u0026#34; href=\u0026#34;https://example.com/tillie\u0026#34; id=\u0026#34;link3\u0026#34;\u0026gt;Tillie\u0026lt;/a\u0026gt;] ","date":"2025-08-05T15:27:58+08:00","image":"https://Entars.github.io/p/beautifulsoup/BeautifulSoup_hu_e96c9b8184c5ae44.png","permalink":"https://Entars.github.io/p/beautifulsoup/","title":"BeautifulSoup"},{"content":"Urllib3 特点： 连接池管理：在客户端和服务器之间复用已有连接，避免每次请求都重新建立新连接，核心是PoolManager,内部维护一个或多个ConnectionPool； 线程安全：适合在多线程环境下进行并发请求； 重试机制：请求失败自动重试； SSL/TLS验证：建立 HTTPS 连接时，客户端校验服务器提供的数字证书是否可信，并通过 TLS 协议完成数据加密通道的协商； 代理支持：在客户端（你）访问目标网站时，通过一个中间服务器（代理服务器）中转请求和响应，而不是直接访问目标网站； 文件上传：支持 multipart 文件上传； 编码处理：自动处理响应内容的编码问题； 核心类与方法： PoolManager：最核心类，负责管理连接池和所有请求。\n1 2 3 4 5 6 7 8 http = urllib3.PoolManager( num_pools = 50, #连接池数量 maxsize = 10, #每个连接池最大连接数 block = True, #连接池满时是否阻塞等待 timeout = 30.0,\t#请求超时时间 retries = 3, #默认重试次数 headers={\u0026#39;User-Agent\u0026#39;:\u0026#39;\u0026#39;} ) GET请求：\n1 2 3 4 5 response = http.request( \u0026#39;GET\u0026#39;, \u0026#39;http://\u0026#39;, fields = {\u0026#39;arg\u0026#39;:\u0026#39;value\u0026#39;} #查询参数 ) POST请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #表单数据 response = http.request( \u0026#39;POST\u0026#39;, \u0026#39;http://\u0026#39;, fields = {\u0026#39;field\u0026#39;:\u0026#39;value\u0026#39;} ) #JSON数据 import json response = http.request( \u0026#39;POST\u0026#39;, \u0026#39;http://\u0026#39;, body = json.dumps({\u0026#39;key\u0026#39;:\u0026#39;value\u0026#39;}).encode(\u0026#39;utf-8\u0026#39;), headers = {\u0026#39;Content-Type\u0026#39;:\u0026#39;application/json\u0026#39;} ) PUT/DELETE请求：\n1 2 3 4 5 6 7 8 9 10 11 12 #PUT请求 response = http.request( \u0026#39;PUT\u0026#39;, \u0026#39;http://\u0026#39;, body = b \u0026#39;data to put\u0026#39; ) #DELETE请求 response = http.request( \u0026#39;DELETE\u0026#39;, \u0026#39;http://\u0026#39; ) 文件上传：\n1 2 3 4 5 6 7 8 9 10 11 with open(\u0026#39;example.txt\u0026#39;,\u0026#39;rb\u0026#39;) as f: file_data = f.read() response = http.request( \u0026#39;POST\u0026#39;, \u0026#39;http://\u0026#39;, fields = { \u0026#39;filefield\u0026#39;:(\u0026#39;example.txt\u0026#39;,file_data,\u0026#39;text/plain\u0026#39;), \u0026#39;description\u0026#39;:\u0026#39;File upload example\u0026#39; } ) 响应处理与重要属性 响应对象属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 response = http.request(\u0026#39;GET\u0026#39;,\u0026#39;http://exmaple.com\u0026#39;) #状态码 print(response.status) #响应头 print(reponse.headers) #响应体 print(response.data) print(response.data.decode(\u0026#39;utf-8\u0026#39;))#解码为字符串 #重新定向历史 print(response.redirect_location) #消耗时间 print(response.elapsed) 响应内容处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #JSON响应处理 import json json_response = json.loads(response.data.decode(\u0026#39;utf-8\u0026#39;)) #流式响应处理 response = http.request( \u0026#39;GET\u0026#39;, \u0026#39;http://exmaple.com/largefile\u0026#39;, preload_content=False ) try: for chunk in response.stream(1024):#每次读1024字节 process_chunk(chunk) finally: response.release_conn()#释放连接 高级特性与配置 重试机制：\n1 2 3 4 5 6 7 8 from urllib3.util.retry import Retry retry_strategy = Retry( total = 3, #重试总次数 backoff_factor = 1, #重试间隔增长因子 status_forcelist = [500,502,503,504]#指定哪些状态码会触发自动重试 ) http = urllib3.PoolManager(retries = retry_strategy) 超时设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #全局超时 http = urllib3.PoolManager(timeout=2.0) #单个请求超时 response = http.request( \u0026#39;GET\u0026#39;, \u0026#39;http://example.com\u0026#39;, timeout=5.0 ) #分别设置连接和读取超时 response = http.request( \u0026#39;GET\u0026#39;, \u0026#39;http://example.com\u0026#39;, timeout=urllib3.Timeout(connect=2.0, read=10.0) ) SSL/TLS配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #禁用证书验证(不推荐生产环境使用) http = urllib3.PoolManager( cert_reqs=\u0026#39;CERT_NONE\u0026#39;,#不校验证书有效性 assert_hostname=False #不检查证书是否匹配域名 ) #自定义CA证书 http = urllib3.PoolManager( cert_reqs=\u0026#39;CERT_REQUIRED\u0026#39;, ca_certs=\u0026#39;/path/to/certificate.pem\u0026#39;)#自定义CA #客户端证书认证 http = urllib3.PoolManager( #证书文件路径 cert_file=\u0026#39;/path/to/client_cert.pem\u0026#39;, #证书对应私钥文件路径 key_file=\u0026#39;/path/to/client_key.pem\u0026#39;) 代理配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #HTTP代理 http = urllib3.ProxyManager( #代理服务器地址 \u0026#39;http://proxy.example.com:8080/\u0026#39;, #身份认证信息 proxy_headers={\u0026#39;Proxy-Authorization\u0026#39;: \u0026#39;Basic ...\u0026#39;}) #SOCKS代理(需要安装PySocks) pip install pysocks from urllib3.contrib.socks import SOCKSProxyManager proxy = SOCKSProxyManager( \u0026#39;socks5://user:password@127.0.0.1:1080/\u0026#39; ) 性能优化技巧 连接池调优：\n1 2 3 4 5 6 7 #根据应用场景调整连接池参数 http = urllib3.PoolManager( num_pools=10, # 适合大多数应用 maxsize=10, # 每个连接池最大连接数 block=True, # 连接池满时阻塞而非创建新连接 timeout=60.0 # 适当延长超时时间 ) 连接重用：\n1 2 3 4 #使用上下文管理器确保连接正确释放 with http.request(\u0026#39;GET\u0026#39;, \u0026#39;http://example.com\u0026#39;, preload_content=False) as response: process_response(response) #连接自动返回到连接池 批处理请求（使用线程池并发发起请求，并收集响应对象）：\n1 2 3 4 5 6 7 8 9 10 11 from concurrent.futures import ThreadPoolExecutor urls = [\u0026#39;http://example.com/1\u0026#39;, \u0026#39;http://example.com/2\u0026#39;, \u0026#39;http://example.com/3\u0026#39;] def fetch(url): return http.request(\u0026#39;GET\u0026#39;, url) with ThreadPoolExecutor(max_workers=5) as executor: results = list(executor.map(fetch, urls)) 6.常见的应用场景 Web API调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import json from urllib.parse import urlencode base_url = \u0026#34;https://api.example.com/v1\u0026#34; def get_user(user_id): response = http.request( \u0026#39;GET\u0026#39;, f\u0026#34;{base_url}/users/{user_id}\u0026#34;, headers={\u0026#39;Authorization\u0026#39;: \u0026#39;Bearer token123\u0026#39;} ) return json.loads(response.data.decode(\u0026#39;utf-8\u0026#39;)) def search_users(query, limit=10): params = {\u0026#39;q\u0026#39;: query, \u0026#39;limit\u0026#39;: limit} response = http.request( \u0026#39;GET\u0026#39;, f\u0026#34;{base_url}/users/search?{urlencode(params)}\u0026#34; ) return json.loads(response.data.decode(\u0026#39;utf-8\u0026#39;)) 网页抓取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from bs4 import BeautifulSoup def scrape_website(url): response = http.request(\u0026#39;GET\u0026#39;, url) if response.status == 200: soup = BeautifulSoup(response.data, \u0026#39;html.parser\u0026#39;) # 提取数据... return { \u0026#39;title\u0026#39;: soup.title.string, #遍历所有的a标签，并提取其中的href属性 \u0026#39;links\u0026#39;: [a[\u0026#39;href\u0026#39;] for a in soup.find_all(\u0026#39;a\u0026#39;)] } return None 文件下载：\n1 2 3 4 5 6 7 8 def download_file(url, save_path): with http.request(\u0026#39;GET\u0026#39;, url, preload_content=False) as response: if response.status == 200: with open(save_path, \u0026#39;wb\u0026#39;) as f: for chunk in response.stream(1024): f.write(chunk) return True return False 微服务通信：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import json def call_service(service_url, method, payload=None): headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;X-Request-ID\u0026#39;: \u0026#39;unique-id-123\u0026#39; } body = json.dumps(payload).encode(\u0026#39;utf-8\u0026#39;) if payload else None response = http.request( method.upper(), service_url, headers=headers, body=body ) if response.status \u0026gt;= 400: raise Exception(f\u0026#34;Service error: {response.status}\u0026#34;) return json.loads(response.data.decode(\u0026#39;utf-8\u0026#39;)) 常见问题 异常处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import urllib3.exceptions try: response = http.request(\u0026#39;GET\u0026#39;, \u0026#39;http://example.com\u0026#39;) except urllib3.exceptions.HTTPError as e: print(f\u0026#34;HTTP错误: {e}\u0026#34;) except urllib3.exceptions.SSLError as e: print(f\u0026#34;SSL错误: {e}\u0026#34;) except urllib3.exceptions.TimeoutError as e: print(f\u0026#34;请求超时: {e}\u0026#34;) except urllib3.exceptions.RequestError as e: print(f\u0026#34;请求错误: {e}\u0026#34;) except Exception as e: print(f\u0026#34;其他错误: {e}\u0026#34;) 调试技巧：\n1 2 3 4 5 6 7 8 9 10 11 #启用调试日志 import logging logging.basicConfig(level=logging.DEBUG) #或者只启用urllib3的调试日志 logger = logging.getLogger(\u0026#39;urllib3\u0026#39;) logger.setLevel(logging.DEBUG) #查看连接池状态 print(http.connection_pool_kw) print(http.pools) 与request库的对比 更底层的控制：直接访问连接池和底层配置 更小的内存占用：没有 requests 的额外抽象层 更早的错误检测：在请求发送前就能检测到某些问题 更灵活的流处理：对大型文件或流式API更友好 大多数情况用request，精细控制或高性能用urllib3 一些问题 Q 当我向https://www.xiaohongshu.com/发起请求失败时，urllib3会自动重新定向到https://www.xiaohongshu.com/explore，这是为什么，程序为什么会知道https://www.xiaohongshu.com/explore是正确的 A 不是urllib3“知道正确地址”，重新定向是服务端的行为，当向https://www.xiaohongshu.com/发起请求后，小红书的服务器会返回一个HTTP 301或302响应，将正确的网址返回给客户端，同时urllib会默认自动跟随重定向。 Q JSON响应处理和流式响应处理的区别 A 对于JSON响应处理，response.data一次性读取全部内容，再将其解析为Python对象；流式响应处理，不会把整个响应体加载进内存。JSON响应处理适用于REST API、结构化数据；流式响应处理适用于下载大文件、音视频流等场景 Q 线程与并发的关系 A 线程是并发的一种实现方式，但并发并不限于线程，线程像“工人”，并发像“工人排班的调度方式”，一个线程处理一个任务，多个线程合作是实现 Q PoolManager和ProxyManager的区别 A ProxyManager是继承自PoolManager，专门用来处理从代理服务器发出的请求，其重写了PoolManager的部分方法，确保所有的请求都从预定的代理进行，并且它能根据目标的URL的方案和代理类型，智能的选择使用HTTP转发或HTTP CONNECT通道 一些测试代码 一些库导入\n1 2 3 4 5 6 7 import urllib3 import threading import time from urllib3.exceptions import EmptyPoolError import json import logging logging.basicConfig(level=logging.DEBUG) 测试连接复用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 创建连接池，最大连接数设置为 1（便于观察复用） http = urllib3.HTTPConnectionPool(\u0026#34;httpbin.org\u0026#34;, maxsize=1) # 第一次请求 print(\u0026#34;第1次请求\u0026#34;) r1 = http.request(\u0026#34;GET\u0026#34;, \u0026#34;/get\u0026#34;) print(\u0026#34;响应状态码:\u0026#34;, r1.status) # 暂停 1 秒 time.sleep(1) # 第二次请求 print(\u0026#34;\\n第2次请求\u0026#34;) r2 = http.request(\u0026#34;GET\u0026#34;, \u0026#34;/get\u0026#34;) print(\u0026#34;响应状态码:\u0026#34;, r2.status) \u0026#39;\u0026#39;\u0026#39; #通过如下方式，检查底层 socket 是否复用 print(\u0026#34;连接池中连接数量:\u0026#34;, len(http.pool)) for conn in http.pool: print(\u0026#34;连接对象:\u0026#34;, conn) \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; #测试“不复用的情况”，可以设置 retries=0，并且让服务器关闭连接 r = http.request(\u0026#34;GET\u0026#34;, \u0026#34;/get\u0026#34;, headers={\u0026#34;Connection\u0026#34;: \u0026#34;close\u0026#34;}) \u0026#39;\u0026#39;\u0026#39; 测试限制连接数+阻塞模式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 设置连接池为 maxsize=1，block=False http = urllib3.HTTPConnectionPool(\u0026#34;httpbin.org\u0026#34;, maxsize=1, block=False) # 请求函数：保持连接占用一段时间 def make_request(name): print(f\u0026#34;[{name}] 准备发送请求\u0026#34;) try: r = http.request(\u0026#34;GET\u0026#34;, \u0026#34;/delay/5\u0026#34;, preload_content=False, timeout=10.0) print(f\u0026#34;[{name}] 已发送请求，延迟读取内容\u0026#34;) time.sleep(6) # 保持连接被占用 r.release_conn() # 主动释放连接 print(f\u0026#34;[{name}] 释放连接\u0026#34;) except EmptyPoolError as e: print(f\u0026#34;[{name}] 连接池耗尽异常: {e}\u0026#34;) except Exception as e: print(f\u0026#34;[{name}] 其他异常: {e}\u0026#34;) # 第一个线程：占住唯一连接 t1 = threading.Thread(target=make_request, args=(\u0026#34;线程1\u0026#34;,)) # 第二个线程：争抢连接 t2 = threading.Thread(target=make_request, args=(\u0026#34;线程2\u0026#34;,)) t1.start() time.sleep(0.2) # 保证线程1先占住连接 t2.start() t1.join() t2.join() \u0026#39;\u0026#39;\u0026#39; 连接池已满且不允许阻塞新的请求时，新的连接请求将会被丢弃。这意味着连接池无法处理所有的请求，可能会导致一些请求失败或被延迟处理。 所以在触发连接池已满的情况下不会报错且能正常运行，但在DEBUG日志下会有警告。 \u0026#39;\u0026#39;\u0026#39; 验证连接池（num_pool）作用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026#39;num_pool控制的是最多允许缓存多少个不同主机的连接池，每一个host:port组合会对应一个connectionpool实例，当请求的host数超过num_pools时，旧的连接池将会被清理(LRU策略)\u0026#39; # 创建连接池管理器，最多2个主机连接池 http = urllib3.PoolManager(num_pools=2, maxsize=1) hosts = [ \u0026#34;http://httpbin.org/get\u0026#34;, \u0026#34;https://www.xiaohongshu.com/explore\u0026#34;, \u0026#34;http://baidu.com\u0026#34; # 任意有效网址也可 ] def fetch(url): try: r = http.request(\u0026#34;GET\u0026#34;, url) print(f\u0026#34;访问 {url} 状态码: {r.status}\u0026#34;) except Exception as e: print(f\u0026#34;访问 {url} 出错: {e}\u0026#34;) # 访问3个不同host，超出num_pools限制 for i in range(2): for url in hosts: fetch(url) time.sleep(0.5) \u0026#39;\u0026#39;\u0026#39; 可以观察到每次发送请求前都得先建立连接，这是因为只能允许存在两个连接池，当继续往里添加连接池时，会把旧的清理，使得再次连接时需要重新建立连接 \u0026#39;\u0026#39;\u0026#39; ","date":"2025-08-05T12:10:50+08:00","image":"https://Entars.github.io/p/urllib3/urllib3_hu_c05e892ee201c66c.png","permalink":"https://Entars.github.io/p/urllib3/","title":"Urllib3"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Entars.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://Entars.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Entars.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://Entars.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Entars.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://Entars.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Entars.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Entars.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://Entars.github.io/p/emoji-support/","title":"Emoji Support"}]